[TOC]

# 计算几何

## 二维几何：

### 点与向量

```c++
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

const double eps=1e-10;
const double PI=acos(-1.0);

struct Point{
    double x,y;
    Point(double x=0,double y=0):x(x),y(y){}
};
typedef Point Vector;
typedef vector<Point> Polygon;

Vector operator -(Point a,Point b){
    return Vector(a.x-b.x,a.y-b.y);
}
Vector operator +(Point a,Point b){
    return Vector(a.x+b.x,a.y+b.y);
}
Vector operator *(Vector a,double p){
    return Vector(a.x*p,a.y*p);
}
Vector operator /(Vector a,double p){
    return Vector(a.x/p,a.y/p);
}
bool operator <(const Point& a,const Point& b){
    return a.x<b.x||(a.x==b.x&&a.y<b.y);//在有精度需求，比如使用lower_bound的时候，加上dcmp()
}
int dcmp(double x){
    if(fabs(x)<eps)return 0;
    if(x<0)return -1;
    return 1;
}
bool operator ==(const Point& a,const Point& b){
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0;
}
double Dot(Vector a,Vector b){
    return a.x*b.x+a.y*b.y;
}//点积
double Cross(Vector a,Vector b){
    return a.x*b.y-a.y*b.x;
}//叉积   
double Length(Vector a){
    return sqrt(Dot(a,a));
}//长度
//返回逆时针旋转90度的单位法向量；
Vector Normal(Vector a){
    double l=Length(a);
    return Vector(-a.y/l,a.x/l);
}
//返回单位向量；
Vector normal(Vector a){
    double l=Length(a);
    return Vector(a.x/l,a.y/l);
}
//返回向量夹角，无方向
double Angle(Vector a,Vector b){
    return acos(Dot(a,b)/Length(a)/Length(b));
}
//逆时针旋转向量
Vector Rotate(Vector a,double rad){
    return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));
}
//求p+v*t与q+w*t的交点，使用时确保Cross(v,w)不等于0
Point GetlineIntersection(Point p,Vector v,Point q,Vector w){
    Vector u=p-q;
    double t=Cross(w,u)/Cross(v,w);
    return p+v*t;
}
//求p到直线ab的距离
double DistanceToline(Point p,Point a,Point b){
    Vector v1=p-a,v2=b-a;
    return fabs(Cross(v1,v2)/Length(v2));
}
//求p到线段ab的距离
double DistanceToSegment(Point p,Point a,Point b){
    if(a==b)return Length(p-a);
    Vector v1=b-a,v2=p-a,v3=p-b;
    if(dcmp(Dot(v1,v2)<0))return Length(p-a);
    else if(dcmp(Dot(v1,v3))>0)return Length(p-b);
    else return fabs(Cross(v1,v2)/Length(v1));
}
//线段a1a2与线段b1b2规范相交返回真
bool SegmenProperIntersection(Point a1,Point a2,Point b1,Point b2){
    double c1=Cross(a2-a1,b1-a1),c2=Cross(a2-a1,b2-a1);
    double c3=Cross(b2-b1,a1-b1),c4=Cross(b2-b1,a2-b1);
    return dcmp(c1)*dcmp(c2)<0&&dcmp(c3)*dcmp(c4)<0;
}
//点p在线段a1a2上返回真
bool OnSegment(Point p,Point a1,Point a2){
    return dcmp(Cross(a1-p,a2-p))==0&&dcmp(Dot(a1-p,a2-p))<0;
}
//点p在ab上的投影
Point GetLineProjection(Point P,Point A,Point B)
{
    Vector v=B-A;
    return A+v*(Dot(v,P-A)/Dot(v,v));
}
//与 x 轴的夹角，取值范围为 (-π，π]
double angle(Vector v){
    return atan2(v.y,v.x);
}
//求线段a1,a2到线段b1,b2的最短距离
double disSegmenttoSegment(Point a1,Point a2,Point b1,Point b2)
{
    double ans=DistanceToSegment(a1,b1,b2);
    ans=min(ans,DistanceToSegment(a2,b1,b2));
    ans=min(ans,DistanceToSegment(b1,a1,a2));
    ans=min(ans,DistanceToSegment(b2,a1,a2));
    return ans;
}
```

###  线

```c++
struct Line{
    Point p;//点
    Vector v;//向量
    double ang;
    Line(){}
    Line(Point p,Vector v):p(p),v(v){ang=atan2(v.y,v.x);}
    Point point(double t){return p+v*t;}
    bool operator <(const Line& L)const{
        return ang<L.ang;
    }
};
//点在直线的左边
bool OnLeft(Line l,Point p)
{
    return Cross(l.v,p-l.p)>0;
}
//两直线交点
Point GetIntersection(Line a,Line b)
{
    Vector u=a.p-b.p;
    double t=Cross(b.v,u)/Cross(a.v,b.v);
    return a.p+a.v*t;
}
```

### 多边形

```c++
typedef vector<Point> Polygon;
//多边形的有向面积，逆时针为正
double PolygonArea(Polygon po) {
    int n = po.size();
    double area = 0.0;
    for(int i = 1; i < n-1; i++) {
        area += Cross(po[i]-po[0], po[i+1]-po[0]);
    }
    return area * 0.5;
}
//点是否在多边形内
int isPointInPolygon(Point p,Point poly[],int n)
{
    int wn=0;
    for(int i=0;i<n;i++){ 
        if(poly[i]==p||poly[(i+1)%n]==p||OnSegment(p,poly[i],poly[(i+1)%n]))return -1;
        int k=dcmp(Cross(poly[(i+1)%n]-poly[i],p-poly[i]));
        int d1=dcmp(poly[i].y-p.y);
        int d2=dcmp(poly[(i+1)%n].y-p.y);
        if(k>0&&d1<=0&&d2>0)
            wn++;
        if(k<0&&d2<=0&&d1>0)
            wn--;
    }
    if(wn!=0)return 1;//内部
    return 0;//外部
}
//求凸包，ch为返回凸包，m为凸包内点的数目，<=不允许点在边上，
int ConvecHull(Point* p,int n,Point* ch)
{
    sort(p,p+n);
    int m=0;
    for(int i=0;i<n;i++){
        while(m>1&&dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0))m--;//注意<=与<的区别
        ch[m++]=p[i];
    }
    int k=m;
    for(int i=n-2;i>=0;i--){
        while(m>k&&dcmp(Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0))m--;//注意<=与<的区别
        ch[m++]=p[i];
    }
    if(n>1)m--;
    return m;
}
```

### 圆

```c++
struct Circle{
    Point c;
    double r;
    Circle(){};
    Circle(Point c,double r=0):c(c),r(r){}
    Point point(double a){
        return Point(c.x+cos(a)*r,c.y+sin(a)*r);
    }
};
//求圆与直线的交点,t1,t2为(at+b)^2+(ct+d)^2=r^2的解，交点放入sol
int getLineCircleIntersection(Line L,Circle C,double& t1,double& t2,vector<Point>& sol)
{
    double a=L.v.x,b=L.p.x-C.c.x,c=L.v.y,d=L.p.y-C.c.y;
    double e=a*a+c*c,f=2*(a*b+c*d),g=b*b+d*d-C.r*C.r;
    double delta=f*f-4*e*g;
    if(dcmp(delta)<0)return 0;
    if(dcmp(delta)==0){
        t1=t2=-f/(2*e);
        sol.push_back(L.point(t1));
        return 1;
    }
    t1=(-f-sqrt(delta))/(2*e);
    sol.push_back(L.point(t1));
    t2=(-f+sqrt(delta))/(2*e);
    sol.push_back(L.point(t2));
    return 2;
}
//求圆与圆的交点，交点放入sol
int getCircleCircleIntersection(Circle C1,Circle C2,vector<Point>& sol)
{
    double d=Length(C1.c-C2.c);
    if(dcmp(d)==0){
        if(dcmp(C1.r-C2.r)==0)return -1;//两圆重合
        return 0;
    }
    if(dcmp(C1.r+C2.r-d)<0)return 0;
    if(dcmp(fabs(C1.r-C2.r)-d)>0)return 0;
    double  a=angle(C2.c-C1.c);//直线c1c2
    double da=acos((C1.r*C1.r+d*d-C2.r*C2.r)/(2*C1.r*d));//c1c2到c1p1的角
    Point p1=C1.point(a-da),p2=C1.point(a+da);
    sol.push_back(p1);
    if(p1==p2)return 1;
    sol.push_back(p2);
    return 2;
}
//求点与圆的切线
int getTangents(Point p,Circle C,Vector* v){
    Vector u=C.c-p;
    double dist=Length(u);
    if(dcmp(dist-C.r)<0)return 0;
    else if(dcmp(dist-C.r)==0){
        v[0]=Rotate(u,PI/2);
        return 1;
    }
    else {
        double ang=asin(C.r/dist);
        v[0]=Rotate(u,-ang);
        v[1]=Rotate(u,+ang);
        return 2;
    }
}
//两圆的公切线
int getTangents(Circle A,Circle B,Point* a,Point* b)
{
	int cnt=0;
	if(A.r<B.r)
	{
		swap(A,B);
		swap(a,b);
	}
	double d2=(A.c.x-B.c.x)*(A.c.x-B.c.x)+(A.c.y-B.c.y)*(A.c.y-B.c.y);//圆心距离的平方
	double rdiff=A.r-B.r;
	double rsum=A.r+B.r;
	if(d2<rdiff*rdiff) return 0;
	//两圆的圆心距离小于半径差
	//内含
	double base=atan2(B.c.y-A.c.y,B.c.x-A.c.x);//圆心连线的极角
	if(d2==0&&A.r==B.r) return -1;//两圆重合
	if(d2==rdiff*rdiff) {
		a[cnt]=A.point(base);b[cnt]=B.point(base);
		cnt++;
		return 1;
	}
	//外公切线
	double ang=acos((A.r-B.r)/sqrt(d2));
	a[cnt]=A.point(base+ang);b[cnt]=B.point(base+ang);cnt++;
	a[cnt]=A.point(base-ang);b[cnt]=B.point(base-ang);cnt++;
	if(d2==rsum*rsum){
		a[cnt]=A.point(base);b[cnt]=B.point(base+PI);cnt++;
	}
	else if(d2>rsum*rsum){//相离
		double ang=acos((A.r+B.r)/sqrt(d2));
		a[cnt]=A.point(base+ang);b[cnt]=B.point(PI+base+ang);cnt++;
		a[cnt]=A.point(base-ang);b[cnt]=B.point(PI+base-ang);cnt++;
	}
	return cnt;
}
```

### 半平面交

```c++
int HalfplaneIntersection(Line* L,int n,Point* poly)
{
    sort(L,L+n);
    int first,last;
    Point *p=new Point[n];//会在函数内开大容量数组，请在使用时注意开成全局！！！！！
    Line *q=new Line[n];//会在函数内开大容量数组，请在使用时注意开成全局！！！！！
    q[first=last=0]=L[0];
    for(int i=1;i<n;i++){
        while(first<last&&!OnLeft(L[i],p[last-1]))last--;
        while(first<last&&!OnLeft(L[i],p[first]))first++;
        q[++last]=L[i];
        if(fabs(Cross(q[last].v,q[last-1].v))<eps){
            last--;
            if(OnLeft(q[last],L[i].p))q[last]=L[i];
        }
        if(first<last)p[last-1]=GetIntersection(q[last-1],q[last]);
    }
    while(first<last&&!OnLeft(q[first],p[last-1]))last--;
    if(last-first<=1)return 0;
    p[last]=GetIntersection(q[last],q[first]);

    int m=0;
    for(int i=first;i<=last;i++)poly[m++]=p[i];
    return m;
}//会在函数内开大容量数组，请在使用时注意开成全局
```

### 平面直线图（PSGL）

```c++
struct Edge
{
    int from, to; // 起点，终点，左边的面编号
    double ang;
    Edge(int f,int t,double a):from(f),to(t),ang(a) {}
};
// 平面直线图（PSGL）实现
struct PSLG {
    int n, m, face_cnt;
    double x[maxn], y[maxn];
    vector<Edge> edges;
    vector<int> G[maxn];
    int vis[maxn*2];  // 每条边是否已经访问过
    int left[maxn*2]; // 左面的编号(该边在哪个面内)
    int prev[maxn*2]; // 相同起点的上一条边（即顺时针旋转碰到的下一条边）的编号

    vector<Polygon> faces;
    double area[maxn]; // 每个polygon的面积

    void init(int n) {
        this->n = n;
        for(int i = 0; i < n; i++) G[i].clear();
        edges.clear();
        faces.clear();
    }

    // 有向线段from->to的极角
    double getAngle(int from, int to) {
        return atan2(y[to]-y[from], x[to]-x[from]);
    }

    void AddEdge(int from, int to) {
        edges.push_back((Edge){from, to, getAngle(from, to)});
        edges.push_back((Edge){to, from, getAngle(to, from)});
        m = edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }

    // 找出faces并计算面积
    void Build() {
        for(int u = 0; u < n; u++) {
            // 给从u出发的各条边按极角排序
            int d = G[u].size();
            for(int i = 0; i < d; i++)
                for(int j = i+1; j < d; j++) // 这里偷个懒，假设从每个点出发的线段不会太多
                    if(edges[G[u][i]].ang > edges[G[u][j]].ang) swap(G[u][i], G[u][j]);
            for(int i = 0; i < d; i++)
                prev[G[u][(i+1)%d]] = G[u][i];  //u点出发的第i条边顺时针转的第一条边是prev[i]
        }

        memset(vis, 0, sizeof(vis));
        face_cnt = 0;
        for(int u = 0; u < n; u++)
            for(int i = 0; i < G[u].size(); i++) {
                int e = G[u][i];  //逆时针转的第i条边
                if(!vis[e]) { // 逆时针找圈
                    face_cnt++;
                    Polygon poly;
                    for(;;) {
                        vis[e] = 1; left[e] = face_cnt;
                        int from = edges[e].from;
                        poly.push_back(Point(x[from], y[from]));
                        //cout<<x[from]<<"   "<<y[from]<<"   ";
                        e = prev[e^1];                    //反向边顺时针第一条
                        if(e == G[u][i]) break;       //回到原点
                        assert(vis[e] == 0);
                    }
                    //cout<<endl;
                    faces.push_back(poly);
                }
            }

        for(int i = 0; i < faces.size(); i++) {
            area[i] = PolygonArea(faces[i]);
        }
    }
};
```

### 旋转卡壳

```c++
//向量(b-a)与向量（c-a)的叉积，相当于三角形abc的有向面积的2倍
double cross(Point a,Point b,Point c)
{
    return Cross(b-a,c-a);
}

//求凸包内最远点
long long getmaxdistance(Point a[],int n)
{
    int j=2;
    double ans=0;
    a[n]=a[0];//方便写下一个点，避免取模
    for(int i=0;i<n;i++){
        while(fabs(cross(a[i],a[i+1],a[j+1]))>fabs(cross(a[i],a[i+1],a[j])))j=(j+1)%n;
        //通过比较面积大小，比较到直线的距离
        ans=max(ans,Length2(a[j]-a[i]));
    }
    return ans;
}

//求2个凸包间的最短距离
double getmindistance(Point p1[],Point p2[],int n1,int n2)
{
    int i=0,j=0;
    for(int k=0;k<n1;k++){
        if(p1[k].y<p1[i].y)i=k;//找出p1中的y最小值的点
    }
    for(int k=0;k<n2;k++){
        if(p2[k].y>p2[j].y)j=k;//找出p2中的y最大值的点
    }
    p1[n1]=p1[0];
    p2[n2]=p2[0];
    double ans=99999999999;
    for(int k=0;k<n1;k++){
        //循环n1次，相当于求p1中每一条边与p2的最近距离
        while((cross(p1[i],p1[i+1],p2[j+1])-cross(p1[i],p1[i+1],p2[j]))>eps)
            j=(j+1)%n2;
        ans=min(ans,disSegmenttoSegment(p1[i],p1[i+1],p2[j],p2[j+1]));//求线段间的最短距离
        i=(i+1)%n1;
    }
    return ans;
}

//求凸包的内4个点组成的最大四边形面积
double solve(Point a[],int n)
{
    a[n]=a[0];
    int p1,p2;
    double ans=0;
    for(int i=0;i<n;i++){
        p1=(i+0)%n;
        p2=(i+1)%n;
        for(int j=i+1;j<n;j++){
            while(cross(a[i],a[j],a[p1+1])<cross(a[i],a[j],a[p1]))p1=(p1+1)%n;
            while(cross(a[i],a[j],a[p2+1])>cross(a[i],a[j],a[p2]))p2=(p2+1)%n;
            ans=max(ans,cross(a[i],a[j],a[p2])-cross(a[i],a[j],a[p1]));
        }
    }
    return ans;
}
```

## 三维几何

### 基础点面

```cpp
struct Point3{
    double x,y,z;
    Point3(double x=0,double y=0,double z=0):x(x),y(y),z(z){}
};

typedef Point3 Vector3;

Vector3 operator +(Vector3 A,Vector3 B){
    return Vector3(A.x+B.x,A.y+B.y,A.z+B.z);
}
Vector3 operator -(Vector3 A,Vector3 B){
    return Vector3(A.x-B.x,A.y-B.y,A.z-B.z);
}
Vector3 operator *(Vector3 A,double p){
    return Vector3(A.x*p,A.y*p,A.z*p);
}
Vector3 operator /(Vector3 A,double p){
    return Vector3(A.x/p,A.y/p,A.z/p);
}
int dcmp(double a){
    if(fabs(a)<eps)return 0;
    else if(a>0)return 1;
    return -1;
}

bool operator ==(Vector3 a,Vector3 b){
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0&&dcmp(a.z-b.z)==0;
}
double Dot(Vector3 A,Vector3 B){
    return A.x*B.x+A.y*B.y+A.z*B.z;
}
double Length(Vector3 A){
    return sqrt(Dot(A,A));
}
double Angle(Vector3 A,Vector3 B){
    return acos(Dot(A,B/Length(A)/Length(B)));
}

//点p到平面p0-n的距离。n必须为单位向量
double DistancetoPlane(const Point3& p,const Point3& p0,const Vector3& n){
    return fabs(Dot(p-p0,n));
}

//点p在平面p0-n上的投影。n必须为单位向量
Point3 GetPlaneProjection(const Point3& p,const Point3& p0,const Vector3& n){
    return p-n*Dot(p-p0,n);
}

//直线p1-p2到平面p0-n的交点。假设交点唯一存在
Point3 LinePlaneIntersection(Point3 p1,Point3 p2,Point3 p0,Vector3 n){
    Vector3 v=p2-p1;
    double t=(Dot(n,p0-p1))/Dot(n,p2-p1);
    return p1+v*t;
}

Vector3 Cross(Vector3 A,Vector3 B){
    return Vector3(A.y*B.z-A.z*B.y,A.z*B.x-A.x*B.z,A.x*B.y-A.y*B.x);
}

double Area2(Point3 A,Point3 B,Point3 C){
    return Length(Cross(B-A,C-A));
}

//点p在△p0p1p2中
bool PointInTri(Point3 p,Point3 p0,Point3 p1,Point3 p2){
    double area1=Area2(p,p0,p1);
    double area2=Area2(p,p1,p2);
    double area3=Area2(p,p2,p0);
    return dcmp(area1+area2+area3-Area2(p0,p1,p2))==0;
}

//△p0p1p2是否和线段ab相交
bool TriSegIntersection(Point3 p0,Point3 p1,Point3 p2,Point3 a,Point3 b,Point3& p)
{
    Vector3 n=Cross(p1-p0,p2-p0);
    if(dcmp(Dot(n,b-a))==0)return false;
    else {
        double t=Dot(n,p0-a)/Dot(n,b-a);
        if(dcmp(t)<0||dcmp(t-1)>0)return false;
        p=a+(b-a)*t;
        return PointInTri(p,p0,p1,p2);
    }
}

//点p到直线ab的距离
double DistancetoLine(Point3 p,Point3 a,Point3 b)
{
    Vector3 v1=b-a,v2=p-a;
    return Length(Cross(v1,v2)/Length(v1));
}

//点p到线段ab的距离
double DistanceToSegment(Point3 p,Point3 a,Point3 b){
    if(a==b)return Length(p-a);
    Vector3 v1=b-a,v2=p-a,v3=p-b;
    if(dcmp(Dot(v1,v2)<0))return Length(v2);
    else if(dcmp(Dot(v1,v3))>0)return Length(v3);
    else return Length(Cross(v1,v2))/Length(v1);
}

//返回ab，ac，ad的混合积。它也等于四面体的有向体积的6倍
double Volume6(Point3 a,Point3 b,Point3 c,Point3 d)
{
    return Dot(d-a,Cross(b-a,c-a));
}
```

### 凸包

```cpp
struct Face{
    int v[3];
    Vector3 normal(Point3 *p)const{
        return Cross(p[v[1]]-p[v[0]],p[v[2]]-p[v[0]]);
    }
    int cansee(Point3 *p,int i)const{
        return Dot(p[i]-p[v[0]],normal(p))>0?1:0;
    }
};
const int N=1e3;
int vis[N][N];
//三维凸包，记得使用前扰动点，以避免特殊情况
vector<Face> CH3D(Point3 *p,int n)
{
    vector<Face> cur;
    //记得提前扰动
    cur.push_back((Face){{0,1,2}});
    cur.push_back((Face){{2,1,0}});
    for(int i=3;i<n;i++){
        vector<Face> next;
        for(int j=0;j<cur.size();j++){
            Face& f=cur[j];
            int res=f.cansee(p,i);
            if(!res)next.push_back(f);
            for(int k=0;k<3;k++)vis[f.v[k]][f.v[(k+1)%3]]=res;
        }
        for(int j=0;j<cur.size();j++){
            for(int k=0;k<3;k++){
                int a=cur[j].v[k],b=cur[j].v[(k+1)%3];
                if(vis[a][b]!=vis[b][a]&&vis[a][b]){
                    next.push_back((Face){{a,b,i}});
                }
            }
        }
        cur=next;
    }
    return cur;
}
double rand01(){
    return rand()/(double)RAND_MAX;
}
double randeps(){
    return (rand01()-0.5)*eps;
}
Point3 add_noise(Point3 p)
{
    return Point3(p.x+randeps(),p.y+randeps(),p.z+randeps());
}
```

## 杂题

### 最大空凸包

```cpp

Point o;
bool cmp(Point& a,Point& b)
{
    if(dcmp(Cross(a-o,b-o))==0){
        return Length(a-o)<Length(b-o);
    }
    return dcmp(Cross(a-o,b-o))>0;
}
double dp[maxn][maxn];
double MEP(Point* p,Point O,int n) {
    sort(p,p+n,cmp);
    memset(dp,0,sizeof(dp));
    double ans=0;
    for(int i=0;i<n;i++) { // O-i 始终作为以st开始的凸包顺时针的第一条边
        int j=i-1;
        while(j>=0 && dcmp(Cross(p[i]-O,p[j]-O))==0) j--;
        // i-j 作为凸包的第二条边
        bool flag=(j==i-1);
        while(j>=0) {
            int k=j-1;
            while(k>=0 && dcmp(Cross(p[i]-p[k],p[j]-p[k]))>0) k--;
            // 找到能作为凸包右下的一点的 k
            double area=abs(Cross(p[i]-O,p[j]-O))/2.0;
            if(k>=0) area+=dp[j][k]; // 已求得的jk的MEP + 三角形Oij
            if(flag) dp[i][j]=area; // j!=i-1时不更新dp数组
            /* 虽然对当前的凸包来说只是边界点没影响
                但是之后其他凸包需利用当前dp[i][j]时
                这些边界点会被包含在凸包内 */
            ans=max(ans,area);
            j=k;
        }
        if(flag)
            for(int j=1;j<i;j++)
                dp[i][j]=max(dp[i][j],dp[i][j-1]);
    }
    return ans;
}
//p为原始点,n为原始点个数,p是为mep函数提前开好的空间
double getans(Point *pa,int n,Point *p)
{
    double ans=0;
    for(int i=0;i<n;i++) {
            o=pa[i];
            int c=0;
            for(int j=0;j<n;j++)
                if(pa[j].y>pa[i].y || dcmp(pa[j].y-pa[i].y)==0&&pa[j].x>pa[i].x)
                    p[c++]=pa[j]; // 取O右上角的点
            ans=max(ans,MEP(p,o,c)); //printf("%.1f\n",ans);
        }
    return ans;
}
```

### pick定理

皮克定理:S=A+B/2-1（S为多边形面积，A为多边形内部整点数，B为多边形边上的整点数）

###扫描线求面积并

求矩形的面积并，poj1151

```cpp
struct seg{
    double l,r,h;
    int v;
    seg(double l=0,double r=0,double h=0,int v=0):l(l),r(r),h(h),v(v){}
    bool operator <(seg& b){
        return h<b.h;
    }
};
struct node{
    double len;
    int v;
};
node t[1000];
double a,b,c,d;
int n,m;
seg s[220];
double x[220];
int cnt;
void pushdown(int l,int r,int rt)
{
    if(t[rt].v>0){
        t[rt].len=x[r+1]-x[l];
    }
    else if(l==r){
        t[rt].len=0;
    }
    else {
        t[rt].len=t[rt<<1].len+t[rt<<1|1].len;
    }
}
void add(int l,int r,int L,int R,int rt,int v)
{
    if(l<=L&&r>=R){
        t[rt].v+=v;
    }
    else {
        int m=(L+R)/2;
        if(l<=m)add(l,r,L,m,rt<<1,v);
        if(r>m)add(l,r,m+1,R,rt<<1|1,v);
    }
    pushdown(L,R,rt);
}
int main()
{
    int cas=1;
    while(cin>>n){
        if(n==0)break;
        cnt=0;
        memset(t,0,sizeof(t));
        for(int i=0;i<n;i++){
            cin>>a>>b>>c>>d;
            x[cnt]=a;
            s[cnt++]=seg(a,c,b,1);
            x[cnt]=c;
            s[cnt++]=seg(a,c,d,-1);
        }
        sort(x,x+cnt);
        sort(s,s+cnt);
        m=unique(x,x+cnt)-x;
        double ans=0;
        int l,r;
        for(int i=0;i<cnt-1;i++){
            l=lower_bound(x,x+m,s[i].l)-x;
            r=lower_bound(x,x+m,s[i].r)-x-1;
            add(l,r,0,m,1,s[i].v);
            ans+=t[1].len*(s[i+1].h-s[i].h);
        }
        cout<<"Test case #"<<cas++<<endl;
        cout<<"Total explored area: ";
        printf("%.2f\n\n",ans);
    }
    return 0;
}
```

### 动态凸包，维护面积

插入的时候赋值给点x

```cpp
set<Point> bst[2];
set<Point>::iterator l,r,t;
Point x;
ll ans;
Point o(0,0);
void erase_l(int i){
    while (l!=bst[i].begin() && Cross(*--(t=l)-*l,x-*l)>=0)
        ans-=Cross(*t,*l),bst[i].erase(l),l=t;
}

void erase_r(int i){
    while (++(t=r)!=bst[i].end() && Cross(x-*r,*t-*r)>=0)
        ans-=Cross(*r,*t),bst[i].erase(r),r=t;
}

void insert(){
    for(int i=0;i<2;i++){
        if (i)x=0-x;
        if ((r=bst[i].lower_bound(x))==bst[i].end()){
            --(l=r),erase_l(i),bst[i].insert(x),ans+=Cross(*l,x);
            continue;
        }
        if (x==*r)
            return;
        if (r!=bst[i].begin()){
            if (Cross(*--(l=r)-x,*r-x)>=0)
                continue;
            ans-=Cross(*l,*r),erase_l(i),ans+=Cross(*l,x);
        }
        erase_r(i),ans+=Cross(x,*r),bst[i].insert(x);
    }
}
bool check(Point p)
{
    bool flag=true;
    for(int i=0;i<2;i++){
        if(i==1)p=o-p;
        it r=bst[i].lower_bound(p);
        if(r==bst[i].end())flag=false;
        else if(r==bst[i].begin()){
            if(!(*r==p))flag=false;
        }
        else {
            it nxt=(--r);r++;
            if(Cross((*r-*nxt),(p-*nxt))<0)flag=false;
        }
    }
    return flag;
}//查找点是否在凸包内
```

### 外接圆，内接圆

```cpp
//三角形外接圆（三点保证不共线）
Circle CircumscribedCircle(Point p1, Point p2, Point p3){
    double Bx = p2.x-p1.x, By = p2.y-p1.y;
    double Cx = p3.x-p1.x, Cy = p3.y-p1.y;
    double D = 2*(Bx*Cy-By*Cx);
    double cx = (Cy*(Bx*Bx+By*By)-By*(Cx*Cx+Cy*Cy))/D+p1.x;
    double cy = (Bx*(Cx*Cx+Cy*Cy)-Cx*(Bx*Bx+By*By))/D+p1.y;
    Point p = Point(cx,cy);
    return Circle(p,Length(p1-p));
}
//三角形内切圆
Circle InscribedCircle(Point p1, Point p2, Point p3){
    double a = Length(p2-p3);
    double b = Length(p3-p1);
    double c = Length(p1-p2);
    Point p = (p1*a+p2*b+p3*c)/(a+b+c);
    return Circle(p, DistanceToLine(p, p1, p2));
}
```

### 三角形面积并

考虑切片，计算每一片的面积，每一片的面积等于宽乘以中线切割的高，复杂度$n^3log(n)$

```cpp
Point p[105][3];
Point a,b,c;
double x[105000];
int cnt;
int n;
void getx(Point a1,Point a2,Point b1,Point b2)
{
    if(SegmenProperIntersection(a1,a2,b1,b2)){
        x[cnt++]=GetlineIntersection(a1,a2-a1,b1,b2-b1).x;
    }
}
struct seg{
    double h;
    int f;
    seg(double a,int b):h(a),f(b){}
};
bool operator<(const seg& a,const seg& b)
{
    return a.h<b.h;
}
double getlenth(vector<seg> v)
{
    sort(v.begin(),v.end());
    int num=v.size(),now=0;
    double ans=0;
    for(int i=0;i<num;i++){
        if(now>0){
            ans+=v[i].h-v[i-1].h;
        }
        now+=v[i].f;
    }
    return ans;
}
double geth(double x)
{
    vector<seg> v;
    Point a1(x,-99999999);
    Point a2(x,99999999);
    double h[2];
    int cnt;
    for(int i=0;i<n;i++){
        cnt=0;
        for(int j=0;j<3;j++){
            if(SegmenProperIntersection(a1,a2,p[i][j],p[i][(j+1)%3])){
                h[cnt++]=GetlineIntersection(a1,a2-a1,p[i][j],p[i][(j+1)%3]-p[i][j]).y;
            }
        }
        if(cnt==2){
            if(h[1]<h[0])swap(h[0],h[1]);
            v.push_back(seg(h[0],1));
            v.push_back(seg(h[1],-1));
        }
    }
    return getlenth(v);
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++){
        p[i][0].read();
        p[i][1].read();
        p[i][2].read();
    }
    for(int i=0;i<n;i++){
        x[cnt++]=p[i][0].x;
        x[cnt++]=p[i][1].x;
        x[cnt++]=p[i][2].x;
        for(int j=i+1;j<n;j++){
            for(int k=0;k<3;k++){
                for(int z=0;z<3;z++){
                    getx(p[i][(0+k)%3],p[i][(1+k)%3],p[j][(0+z)%3],p[j][(1+z)%3]);
                }
            }
        }
    }
    sort(x,x+cnt);
    cnt=unique(x,x+cnt)-x;
    double m,h;
    double ans=0;
    for(int i=1;i<cnt;i++){
        m=(x[i-1]+x[i])/2;
        h=geth(m);
        ans+=(x[i]-x[i-1])*h;
    }
    printf("%.2f\n",ans);
    return 0;
}
```

### 圆的反演

```cpp
Circle inverse(Circle a)
{
    Circle ans;
    double oc1=Length(p-a.c);
    double k1=1.0/(oc1-a.r);
    double k2=1.0/(oc1+a.r);
    ans.r=0.5*(k1-k2);
    double oc2=0.5*(k1+k2);
    ans.c=p+(a.c-p)*oc2/oc1;
    return ans;
}

void mark(Point a,Point b)
{
    //++cnt;
    double tem=fabs(Cross(p-a,b-a)/Length(a-b));
    if(tem>eps){
        ++cnt;
        double w=0.5/tem;
        Point dir=Normal(b-a);
        Point a1=p+dir*w;
        Point b1=p-dir*w;
        if(fabs(Cross(b-a,a1-a))<fabs(Cross(b-a,b1-a)))c[cnt]=Circle(a1,w);
        else c[cnt]=Circle(b1,w);
    }
}
```

