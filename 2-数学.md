[TOC]

# 数学



## 数论



### 莫比乌斯反演（筛积性函数+数论分块）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5;
int mu[maxn+50],prime[maxn+50],sum[maxn+50];
bool f[maxn+50];
int a,b,c,d,k;
long long solve(int n,int m)
{
    if(n>m) swap(n,m);
    long long ans=0;
    for(int i=1,la=0;i<=n;i=la+1)
    {
        la=min(n/(n/i),m/(m/i));
        ans+=(long long)(sum[la]-sum[i-1])*(n/i)*(m/i);
    }//对于n/i * m/i 采用分块求和的根号n+根号m的做法
    return ans;
}
int main()
{
    mu[1]=1;
    memset(f,0,sizeof(f));
    f[1]=1;
    for(int i=2;i<=maxn;++i)
    {
        if(!f[i])
        {
            prime[++prime[0]]=i;
            mu[i]=-1;
        }
        for(int j=1;j<=prime[0];++j)
        {
            if(i*prime[j]>maxn) break;
            f[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                mu[i*prime[j]]=0;
                break;
            }
            else mu[i*prime[j]]=-mu[i];
        }
    }//筛积性函数
    memset(sum,0,sizeof(sum));
    sum[1]=mu[1];
    for(int i=2;i<=maxn;++i) sum[i]=sum[i-1]+mu[i];
    int T;
    scanf("%d",&T);
    for(int cas=1;cas<=T;++cas)
    {
        printf("Case %d: ",cas);
        scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
        if(k==0) printf("0\n");else
        {
            long long ans=solve(b/k,d/k)-solve((a-1)/k,d/k)-solve(b/k,(c-1)/k)+solve((a-1)/k,(c-1)/k);
            a=max(a,c),b=min(b,d);
            long long ans1=solve(b/k,b/k)-solve((a-1)/k,b/k)-solve(b/k,(a-1)/k)+solve((a-1)/k,(a-1)/k);
            printf("%lld\n",ans-ans1/2);
        }
    }
    return 0;
}
```



### CRT

```cpp
void gcd(ll a,ll b,ll &d,ll &x,ll &y)
{
    if(!b)
    {
        d=a,x=1,y=0;
        return;
    }
    gcd(b,a%b,d,y,x);
    y-=x*(a/b);
}
ll inv(ll a,ll n)
{
    ll d,x,y;
    gcd(a,n,d,x,y);
    return d==1?(x+n)%n:-1;
}
ll CRT(int n,ll *a,ll *m)
{
    /*n个方程 x=a[i] (mod m[i])   (0<=i<n)*/
    ll M=1,d,y,x=0;
    for(int i=0;i<n;++i) M*=m[i];
    for(int i=0;i<n;++i)
    {
        ll w=M/m[i];
        gcd(m[i],w,d,d,y);
        x=(x+y*w*a[i])%M;
    }
    return (x+M)%M;
}
```



### 扩展lucas

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace exlucas
{
	const int N = 1e6;
	typedef long long ll;
	ll n, m, p;
	inline ll power(ll a, ll b, const ll p = LLONG_MAX)
	{
		ll ans = 1;
		while (b)
		{
			if (b & 1)
				ans = ans * a % p;
			a = a * a % p;
			b >>= 1;
		}
		return ans;
	}
	ll fac(const ll n, const ll p, const ll pk)
	{
	    //求n!/p^a % p^k
	    //若要求n! % p^k  那还要多算上p^(n/p)的贡献
		if (!n) return 1;
		ll ans = 1;
		for (int i = 1; i < pk; i++)
			if (i % p) ans = ans * i % pk;
		ans = power(ans, n / pk, pk);
		for (int i = 1; i <= n % pk; i++)
			if (i % p) ans = ans * i % pk;
		return ans * fac(n / p, p, pk) % pk;
	}
	ll exgcd(const ll a, const ll b, ll &x, ll &y)
	{
		if (!b)
		{
			x = 1, y = 0;
			return a;
		}
		ll xx, yy, g = exgcd(b, a % b, xx, yy);
		x = yy;
		y = xx - a / b * yy;
		return g;
	}
	ll inv(const ll a, const ll p)
	{
		ll x, y;
		exgcd(a, p, x, y);
		return (x % p + p) % p;
	}
	ll C(const ll n, const ll m, const ll p, const ll pk)
	{
	    //求C(n,m) % p^k
		if (n < m) return 0;
		ll f1 = fac(n, p, pk), f2 = fac(m, p, pk), f3 = fac(n - m, p, pk), cnt = 0;
		for (ll i = n; i; i /= p) cnt += i / p;
		for (ll i = m; i; i /= p) cnt -= i / p;
		for (ll i = n - m; i; i /= p) cnt -= i / p;
		return f1 * inv(f2, pk) % pk * inv(f3, pk) % pk * power(p, cnt, pk) % pk;
	}
	ll a[N], c[N];
	int cnt;
	inline ll CRT()
	{
		ll M = 1, ans = 0;
		for (int i = 0; i < cnt; i++) M *= c[i];
		for (int i = 0; i < cnt; i++)
            ans = (ans + a[i] * (M / c[i]) % M * inv(M / c[i], c[i]) % M) % M;
		return ans;
	}
	ll exlucas(const ll n, const ll m, ll p)
	{
	    //将p分解成p^i的形式，各自求解，然后CRT
		ll tmp = sqrt(p);
		for (int i = 2; p > 1 && i <= tmp; i++)
		{
			ll tmp = 1;
			while (p % i == 0) p /= i, tmp *= i;
			if (tmp > 1)
				a[cnt] = C(n, m, i, tmp), c[cnt++] = tmp;
		}
		if (p > 1)
			a[cnt] = C(n, m, p, p), c[cnt++] = p;
		return CRT();
	}
}
int main()
{
    long long n,m,p;
    cin>>n>>m>>p;
	cout<<exlucas::exlucas(n,m,p)<<endl;
	return 0;
}
```





### 类欧几里得

- $m = \lfloor \frac{an+b}{c} \rfloor$.

- $f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor$: 

  当 $a \ge c$ or $b \ge c$ 时，$f(a,b,c,n)=(\frac{a}{c})n(n+1)/2+(\frac{b}{c})(n+1)+f(a \bmod c,b \bmod c,c,n)$；

  否则 $f(a,b,c,n)=nm-f(c,c-b-1,a,m-1)$。

- $g(a,b,c,n)=\sum_{i=0}^n i \lfloor\frac{ai+b}{c}\rfloor$: 

  当 $a \ge c$ or $b \ge c$ 时$g(a,b,c,n)=(\frac{a}{c})n(n+1)(2n+1)/6+(\frac{b}{c})n(n+1)/2+g(a \bmod c,b \bmod c,c,n)$

  否则 $g(a,b,c,n)=\frac{1}{2} (n(n+1)m-f(c,c-b-1,a,m-1)-h(c,c-b-1,a,m-1))$。

- $h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2$: 

  当 $a \ge c$ or $b \ge c$ 时，$h(a,b,c,n)=(\frac{a}{c})^2 n(n+1)(2n+1)/6 +(\frac{b}{c})^2 (n+1)+(\frac{a}{c})(\frac{b}{c})n(n+1)+h(a \bmod c, b \bmod c,c,n)+2(\frac{a}{c})g(a \bmod c,b \bmod c,c,n)+2(\frac{b}{c})f(a \bmod c,b \bmod c,c,n)$；

  否则 $h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)$

```cpp
typedef long long ll;
ll solve(ll a,ll b,ll c,ll n)
{
    /*
    计算 \sum_{i=0..n} (ax+b)/c 的值
    */
    if(n<0) return 0;
    if(c<0) a=-a,b=-b,c=-c;
    if(a<0) b+=a*n,a=-a;
    if(b<0)
    {
        ll p=(-b)/c+1;
        //(a*x+b+p*c)/c-p
        return (solve(a,b+p*c,c,n)-p*(n+1))%mod;
    }
    if(a==0)
        return (b/c)*(n+1)%mod;
    if(a>=c)
        return (n*(n+1)/2%mod*(a/c)%mod+solve(a%c,b,c,n))%mod;
    if(b>=c)
        return ((b/c)*(n+1)%mod+solve(a,b%c,c,n))%mod;
    //LL m=(a*n+b)/c%MOD;
    ll m=(n/c*a+(n%c*a+b)/c);
    return ((m%mod)*(n%mod)%mod-solve(c,c-b-1,a,m-1)+mod)%mod;
}
ll cal(ll a,ll b,ll c,ll n)
{
/*
计算y=(ax+b)/c下方整点个数，x=0..n
要求a>=0,c>0
*/
    if(b>=0) return (solve(a,b,c,n)+n%mod+1)%mod;
    ll x=(-b)/a;
    if(x*a+b<0) ++x;
    if(n<x) return 0;
    b+=a*x;
    return (solve(a,b,c,n-x)+(n-x)%mod+1)%mod;
}
```



### 杜教筛

```cpp
#include<bits/stdc++.h>
#define debug cout<<"debug "<<++debug_num<<" :"
#define pb push_back
#define mp make_pair
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define bit(a,b) ((a>>b)&1) //from 0
#define all(x) (x).begin(),(x).end()
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
int debug_num=0;

const int maxn=5e6+10;
bool valid[maxn];
ll phi[maxn];
int mu[maxn];
int ans[maxn/10];
int tot;
int up;
int m;
const int maxm=(1LL<<32)/maxn;
ll help1[maxm];
int help2[maxm];
bool vis[maxm];

void get_prime(int n)
{
    memset(valid,true,sizeof(valid));
    tot=0;
    phi[1]=mu[1]=1;
    for(int i=2;i<=n;++i){
        if(valid[i]){
            ans[++tot]=i;
            mu[i]=-1;
            phi[i]=i-1;
        }
        for(int j=1;j<=tot && i*ans[j]<=n;++j){
            int tp=i*ans[j];
            valid[tp]=false;
            if(i%ans[j]==0){
                mu[tp]=0;
                phi[tp]=phi[i]*ans[j];
                break;
            }
            else{
                mu[tp]=-mu[i];
                phi[tp]=phi[i]*(ans[j]-1);
            }
        }
    }
    for(int i=1;i<=n;++i){
        phi[i]=phi[i-1]+phi[i];
        mu[i]+=mu[i-1];
    }
}

ll get_phi(ll n)
{
    return (n<=up)? phi[n] : help1[m/n];
}

ll get_mu(ll n)
{
    return (n<=up)? mu[n] : help2[m/n];
}

void solve(ll n)
{
    int t=m/n;
    if(n<=up || vis[t]) return ;
    vis[t]=true;
    help1[t]=n*(n+1)/2;//单位函数前缀和
    help2[t]=1;//恒等函数前缀和
    for(ll l=2,r;l<=n;l=r+1){
        r=n/(n/l);
        solve(n/r);
        help1[t]=help1[t]-(r-l+1)*get_phi(n/r);
        help2[t]=help2[t]-(r-l+1)*get_mu(n/r);
    }
}

int main()
{
    //freopen("in.txt","r",stdin);
    up=maxn-10;
    get_prime(up);
    //cout<<clock()<<endl;
    //cout<<tot<<endl;
    //cout<<phi[up]<<endl;
    //for(int i=1;i<=up;++i) if(mu[i]==0) cout<<"fuck"<<endl;
    int t,n;
    cin>>t;
    while(t--)
    {
        cin>>n;
        m=n;
        if(n<=up) cout<<phi[n]<<" "<<mu[n]<<endl;
        else{
            memset(vis,0,sizeof(vis));//注意清空
            solve(n);
            cout<<help1[1]<<" "<<help2[1]<<endl;
        }
    }
    return 0;
}
```



### O(1)快速乘

```cpp
inline ll multi(ll x,ll y,ll mod)
{
	ll tmp=(x*y-(ll)((long double)x/mod*y+1.0e-8)*mod);
    return tmp<0 ? tmp+mod : tmp;
}
```



### min25筛

```cpp
//f(1)=1
//f(p)=p^2-p
//f(p^e)=(p-1)p^(2e-1)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9+7,inv6=166666668;
ll n,M;
//pre[d][i]预处理的是2~i中的p^d的和 p是素数
//suf[d][i]预处理2~n/i的p^d的和 p是素数
//pre[0][i]预处理的是2~i中p^2-p的和 p是素数
//suf[0][i]预处理的是2~n/i中p^2-p的和 p是素数
vector<ll> pre[3],suf[3],prime;
//res是n/枚举的数
ll mul(ll a,ll b)
{
    return a*b%mod;
}
ll add(ll a,ll b)
{
    return (a+b)%mod;
}
ll sub(ll a,ll b)
{
    return (a-b)%mod;
}
ll dfs(ll res,int last,ll f)
{
    ll t=(res>M?suf[0][n/res]:pre[0][res])-pre[0][prime[last]-1];
    t%=mod;
    ll ans=mul(t,f);//需要修改
    for(int i=last;i<(int)prime.size();++i)
    {
        int p=prime[i];
        if(1LL*p*p>res) break;
        for(ll q=p,nres=res,nf=f*p%mod*(p-1)%mod;q*p<=res;q*=p)//nf需要修改
        {
            ans=add(ans,dfs(nres/=p,i+1,nf));   //枚举更大的数
            nf=mul(nf,mul(p,p));    //需要修改，继续枚举当前素数，指数大于1的时候，指数每+1，nf*=p^2
            ans=add(ans,nf);        //指数大于1的时候记上贡献
        }
    }
    return ans;
}
ll f(ll x)
{
    return x*(1+x)/2%mod;
}
ll ff(ll x)
{
    return x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
}
ll solve(ll n)
{
    M=sqrt(n);
    for(int i=0;i<3;++i) pre[i].clear(),pre[i].resize(M+1);
    for(int i=0;i<3;++i) suf[i].clear(),suf[i].resize(M+1);
    prime.clear();
    for(int i=1;i<=M;++i)
    {
        pre[1][i]=f(i)-1;
        suf[1][i]=f(n/i)-1;
        pre[2][i]=ff(i)-1;
        suf[2][i]=ff(n/i)-1;
    }
    for(int p=2;p<=M;++p)
    {
        if(pre[1][p]==pre[1][p-1]) continue;
        prime.push_back(p);
        const ll q=1LL*p*p,m=n/p,pnt[3]={0,pre[1][p-1],pre[2][p-1]};
        const int mid=M/p;
        const int End=min((ll)M,n/q);
        for(int i=1;i<=mid;++i)
        {
            suf[1][i]=sub(suf[1][i],(suf[1][i*p]-pnt[1])*p%mod);
            suf[2][i]=sub(suf[2][i],(suf[2][i*p]-pnt[2])*p%mod*p%mod);
        }
        for(int i=mid+1;i<=End;++i)
        {
            suf[1][i]=sub(suf[1][i],(pre[1][m/i]-pnt[1])*p%mod);
            suf[2][i]=sub(suf[2][i],(pre[2][m/i]-pnt[2])*p%mod*p%mod);
        }
        for(int i=M;i>=q;--i)
        {
            pre[1][i]=sub(pre[1][i],(pre[1][i/p]-pnt[1])*p%mod);
            pre[2][i]=sub(pre[2][i],(pre[2][i/p]-pnt[2])*p%mod*p%mod);
        }
    }
    for(int i=1;i<=M;++i)
    {
        pre[0][i]=(pre[2][i]-pre[1][i])%mod;
        suf[0][i]=(suf[2][i]-suf[1][i])%mod;
    }
    prime.push_back(M+1);
    return n>1?1+dfs(n,0,1):1;
}
int main()
{
    scanf("%lld",&n);
    printf("1\n%lld\n",(solve(n)+mod)%mod);
    return 0;
}
```



### 矩阵类

```cpp
struct Mat 
{
    static const int M = 64;
    int v[M][M];
    int n,m;
    Mat(){memset(v,0,sizeof(v));}
    Mat(int _n)
    {
        n=m=_n;
        memset(v,0,sizeof(v));
    }
    Mat(int _n,int _m)
    {
        n=_n,m=_m;
        memset(v,0,sizeof(v));
    }
    void eye() 
    { 
        assert(n==m);
        for(int i=0;i<n;++i) v[i][i] = 1; 
    }
    int* operator [] (int x) { return v[x]; }
    const int* operator [] (int x) const { return v[x]; }
    Mat operator * (const Mat& B) {
        assert(m==B.n);
        const Mat& A = *this;
        Mat ret(n,B.m);
        for(int k=0;k<m;++k)
            for(int i=0;i<n;++i)
                if(A[i][k])
                for(int j=0;j<B.m;++j)  
                    ret[i][j] = (ret[i][j] + 1LL*A[i][k] * B[k][j]) % mod;
        return ret;
    }
    Mat pow(int b) const 
    {
        assert(n==m);
        Mat A = *this, ret(n); ret.eye();
        for (; b; b >>= 1, A = A * A)
            if (b & 1) ret = ret * A;
        return ret;
    }
    Mat operator + (const Mat& B) 
    {
        assert(n==B.n&&m==B.m);
        const Mat& A = *this;
        Mat ret(n,m);
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                 ret[i][j] = (A[i][j] + B[i][j]) % mod;
        return ret;
    }
    void prt() const {
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                 printf("%d%c", (*this)[i][j], j == m - 1 ? '\n' : ' ');
    }
}trans;
```

### 反演

#### 二项式反演

$$
\begin{aligned} f_{n} &=\sum_{i=0}^{n}\left(\begin{array}{c}{n} \\ {i}\end{array}\right) g_{i} \\ g_{n} &=\sum_{i=0}^{n}(-1)^{n-i}\left(\begin{array}{c}{n} \\ {i}\end{array}\right) f_{i} \end{aligned}
$$

$$
\begin{aligned} f_{k} &=\sum_{i=k}^{n}\left(\begin{array}{c}{i} \\ {k}\end{array}\right) g_{i} \\ g_{k} &=\sum_{i=k}^{n}\left(\begin{array}{c}{i} \\ {k}\end{array}\right) f_{i}(-1)^{i-k} \end{aligned}
$$

#### 斯特林反演

$$
\begin{aligned} f(n) &=\sum_{i=1}^{n}\left\{\begin{array}{c}{n} \\ {i}\end{array}\right\} g(i) \\ g(n) &=\sum_{i=0}^{n}(-1)^{n-i}\left[\begin{array}{c}{n} \\ {i}\end{array}\right] f(i) \end{aligned}
$$

### 斯特林数

#### 第一类斯特林数

- $n$个数的序列分为$k$个圆排列的方案数。
- $s(n,k)=s(n-1,k-1)+(n-1)s(n-1,k)$
- $s(n,k)$是多项式$(x+0)(x+1)(x+2)...(x+(n-1))$的$k$次项系数。
- $n!=\sum_{i=0}^n s(n,i)$
- $x^{\underline{n}}=\sum_{i=0}^ns(n,i)(-1)^{n-i}x^i$ 

##### 求第一类斯特林数的第n行

$O(nlogn)$

```cpp
#include<bits/stdc++.h>
typedef long long ll;
const int maxn = 550050;
const int mod = 167772161;
const int G=3;
ll pow_mod(ll a, ll b) {
  ll ans = 1;
  for (; b; b >>= 1, a = a * a % mod)
    if (b & 1) ans = ans * a % mod;
  return ans;
}

int L, rev[maxn];
ll w[maxn], inv[maxn], fac[maxn], ifac[maxn];

void Init(int n) {
  L = 1;
  while (L <= n) L <<= 1;
  for (int i = 1; i < L; ++i)
    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * L / 2);
  ll wn = pow_mod(G, (mod - 1) / L);
  w[L >> 1] = 1;
  for (int i = L >> 1; i < L; ++i) w[i + 1] = w[i] * wn % mod;
  for (int i = (L >> 1) - 1; i; --i) w[i] = w[i << 1];
}

void DFT(ll *A, int len) {
  int k = __builtin_ctz(L) - __builtin_ctz(len);
  for (int i = 1; i < len; ++i) {
    int j = rev[i] >> k;
    if (j > i) std::swap(A[i], A[j]);
  }
  for (int h = 1; h < len; h <<= 1)
    for (int i = 0; i < len; i += (h << 1))
      for (int j = 0; j < h; ++j) {
        ll t = A[i + j + h] * w[j + h] % mod;
        A[i + j + h] = A[i + j] - t;
        A[i + j] += t;
      }
  for (int i = 0; i < len; ++i) A[i] %= mod;
}

void IDFT(ll *A, int len) {
  std::reverse(A + 1, A + len);
  DFT(A, len);
  int v = mod - (mod - 1) / len;
  for (int i = 0; i < len; ++i) A[i] = A[i] * v % mod;
}

void offset(const ll *f, int n, ll c, ll *g) {
  // g(x) = f(x + c)
  // g[i] = 1/i! sum_{j=i}^n j!f[j] c^(j-i)/(j-i)!
  static ll tA[maxn], tB[maxn];
  int l = 1; while (l <= n + n) l <<= 1;
  for (int i = 0; i < n; ++i) tA[n - i - 1] = f[i] * fac[i] % mod;
  ll pc = 1;
  for (int i = 0; i < n; ++i, pc = pc * c % mod) tB[i] = pc * ifac[i] % mod;
  for (int i = n; i < l; ++i) tA[i] = tB[i] = 0;
  DFT(tA, l); DFT(tB, l);
  for (int i = 0; i < l; ++i) tA[i] = tA[i] * tB[i] % mod;
  IDFT(tA, l);
  for (int i = 0; i < n; ++i)
    g[i] = tA[n - i - 1] * ifac[i] % mod;
}

void Solve(int n, ll *f) {
  if (n == 0) return void(f[0] = 1);
  static ll tA[maxn], tB[maxn];
  int m = n / 2;
  Solve(m, f);
  int l = 1; while (l <= n) l <<= 1;
  offset(f, m + 1, m, tA);
  for (int i = 0; i <= m; ++i) tB[i] = f[i];
  for (int i = m + 1; i < l; ++i) tA[i] = tB[i] = 0;
  DFT(tA, l); DFT(tB, l);
  for (int i = 0; i < l; ++i) tA[i] = tA[i] * tB[i] % mod;
  IDFT(tA, l);
  if (n & 1)
    for (int i = 0; i <= n; ++i)
      f[i] = ((i ? tA[i - 1] : 0) + (n - 1) * tA[i]) % mod;
  else
    for (int i = 0; i <= n; ++i)
      f[i] = tA[i];
}

ll f[maxn];

int main()
{
    int n;
    scanf("%d", &n);
    Init(n * 2);
    inv[1] = 1;
    for (int i = 2; i <= n; ++i) inv[i] = -(mod / i) * inv[mod % i] % mod;
    fac[0] = ifac[0] = 1;
    for (int i = 1; i <= n; ++i)
    {
        fac[i] = fac[i - 1] * i % mod;
        ifac[i] = ifac[i - 1] * inv[i] % mod;
    }
    Solve(n, f);
    for (int i = 0; i <= n; ++i)
        printf("%lld ", (f[i] + mod) % mod);
    return 0;
}
```

#### 第二类斯特林数

- $n$ 个元素划分为 $k$ 个等价类的方案数
- $S(n, k)=S(n-1,k-1)+kS(n-1, k)$
- $S(n,m)=\frac{1}{m!}\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n$
- 显然直接卷积在$O(nlogn)$的时间内可以预处理一行
- $m^n=\sum_{i=0}^mS(n,i){m\choose i}i!=\sum_{i=0}^m S(n,i)m^{\underline i}$

```cpp
S[0][0] = 1;
FOR (i, 1, N)
    FOR (j, 1, i + 1) S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD;
```

#### 贝尔数

* $B_n$表示大小为$n$的集合的划分数。

* $B_n=\sum_{m=0}^n S(n,m)$
* $B_{n+1}=\sum_{k=0}^n \binom{n}{k}B_k$
* $\sum_{n=0}^\infty \frac{B_n}{n!}x^n=e^{e^x-1}$
* 若$p$是任意素数，那么$B_{p+n}=B_n+B_{n+1} (mod \ p)$

$O(nlogn)$求贝尔数，要求有逆元。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int p = 998244353;
const int N = 1e5+10;
int fac[N] , facinv[N] , n , a[N] , b[N] , sum[N] , ans;
int qpow(int a, int b, int p) {
	int res = 1;
	for(; b; b >>= 1, a = 1ll * a * a % p) {
		if(b & 1) res = 1ll * res * a % p;
	}
	return res;
}
void pre() {
	facinv[0] = fac[0] = 1;
	for(int i = 1; i <= n; i ++ ) {
		fac[i] = 1ll * fac[i-1] * i % p ;
		facinv[i] = qpow( fac[i] , p - 2 , p ) ;
	}
}

int main()
{
	scanf("%d", &n);
	pre();
	for (int i = 0 ; i <= n ; i++) {
		a[i] = facinv[i];
		if ( i & 1 ) a[i] = p - a[i] ;
		b[i] = 1ll * qpow( i , n , p ) * facinv[i] % p;
		sum[i] = ( ( i ? sum[i-1] : sum[i] ) + b[i] ) % p;
	}
	for (int i = 0 ; i <= n ; i++ ) ans = ( ans + 1ll * a[i] * sum[n-i] % p ) % p;
	cout<<ans;
	return 0;
}
```



### 自然数幂和

我们要求$S_m(n)=\sum_{k=0}^n k^m$，其中$m>0$

#### 求第$n$项的值

* 拉格朗日插值，$O(mlogm)$，要求有逆元。

* 可以利用第二类斯特林数处理自然数幂和，$O(m^2)$，不需要有逆元。

  $S_m(n)=\sum_{j=0}^m\begin{Bmatrix}m\\j\end{Bmatrix}\frac{(n+1)^{\underline {j+1}}}{j+1}$

* 利用伯努利数预处理自然数幂和，同样是$O(m^2)$的。

  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cstdlib>
  #include<cstring>
  #include<cmath>
  #include<algorithm>
  #include<set>
  #include<map>
  #include<vector>
  #include<queue>
  using namespace std;
  #define ll long long
  #define RG register
  #define MOD 1000000007
  #define MAX 2500
  inline ll read()
  {
      RG ll x=0,t=1;RG char ch=getchar();
      while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
      if(ch=='-')t=-1,ch=getchar();
      while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
      return x*t;
  }
  int fpow(int a,int b)
  {
      int s=1;
      while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}
      return s;
  }
  int B[MAX],jc[MAX],jv[MAX],inv[MAX];
  int C(int n,int m){return 1ll*jc[n]*jv[m]%MOD*jv[n-m]%MOD;}
  int main()
  {
      B[0]=jc[0]=jv[0]=inv[0]=inv[1]=1;
      for(int i=2;i<MAX;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
      for(int i=1;i<MAX;++i)jc[i]=1ll*jc[i-1]*i%MOD;
      for(int i=1;i<MAX;++i)jv[i]=1ll*jv[i-1]*inv[i]%MOD;
      for(int i=1;i<MAX;++i)
      {
          for(int j=0;j<i;++j)B[i]=(B[i]+1ll*B[j]*C(i+1,j))%MOD;
          B[i]=1ll*B[i]*inv[i+1]%MOD;B[i]=(MOD-B[i])%MOD;
      }
      int T=read();
      while(T--)
      {
          ll n=read();int k=read(),ans=0;
          int nw=(n+1)%MOD,q=(n+1)%MOD;
          for(int i=k;~i;--i,nw=1ll*nw*q%MOD)ans=(ans+1ll*C(k+1,i)*B[i]%MOD*nw)%MOD;
          ans=1ll*ans*inv[k+1]%MOD;
          printf("%d\n",ans);
      }
      return 0;
  }
  ```

  

#### 求出这个$m+1$次多项式每一项的系数

* 拉格朗日插值，$O(m^2)$。

* 利用第二类斯特林数处理。$O(m^2)$。

  $$
\begin{aligned} T(x) &=\sum_{k=0}^{m}\left\{\begin{array}{c}{m} \\ {k}\end{array}\right\} \frac{1}{k+1}\left[\begin{array}{c}{k} \\ {x}\end{array}\right](-1)^{k-x} \\ &=(-1)^{x} \sum_{k=0}^{m}\left\{\begin{array}{c}{m} \\ {k}\end{array}\right\}\left[\begin{array}{c}{k} \\ {x}\end{array}\right] \frac{(-1)^{k}}{k+1} \end{aligned}
  $$
$S_m(n)=\sum_{j=1}^{m+1} n^j[T(j)+T(j-1)]$
  
  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  using namespace std;
  typedef long long ll;
  const ll p=998244353;
  inline ll add(ll a,ll b){return a+b>=p?a+b-p:a+b;}
  inline ll cut(ll a,ll b){return a-b<0?a-b+p:a-b;}
  inline ll mul(ll a,ll b){return a*b%p;}
  inline ll pow(ll a,ll b){
      ll ans=1;
      while(b){
          if(b&1)ans=mul(ans,a);
          a=mul(a,a);
          b>>=1;
      }
      return ans;
  }
  inline ll div(ll a,ll b){return mul(a,pow(b,p-2));}
  int m;
  ll S1[1001][1001],S2[1001][1001],t[1001];
  bool fir;
  int main(){
      scanf("%d",&m);
      S1[0][0]=S2[0][0]=1;
      for(int i=1;i<=m;i++){
          for(int j=1;j<=m;j++){
              S1[i][j]=add(S1[i-1][j-1],mul(S1[i-1][j],(i-1)));
              S2[i][j]=add(S2[i-1][j-1],mul(S2[i-1][j],j));
          }
      }
      for(int i=1;i<=m;i++){
          for(int j=1;j<=m;j++){
              ll pw=(j%2?p-1:1);
              t[i]=add(t[i],mul(mul(S2[m][j],S1[j][i]),div(pw,j+1)));
          }
          t[i]=mul(t[i],i%2?p-1:1);
      }
      for(int i=0;i<=m+1;i++)printf("%lld ",add(t[i],t[i-1]));
  }
  ```



## 多项式

### FFT

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=400000;
const double pi=acos(-1.0);
int l,m,n,num;
int a[maxn+50],b[maxn+50];
struct wjmzbmr
{
    double r,i;
    wjmzbmr(double real=0.0,double image=0.0){r=real;i=image;}
    wjmzbmr operator + (const wjmzbmr o)
    {
        return wjmzbmr(r+o.r,i+o.i);
    }
    wjmzbmr operator - (const wjmzbmr o)
    {
        return wjmzbmr(r-o.r,i-o.i);
    }
    wjmzbmr operator * (const wjmzbmr o)
    {
        return wjmzbmr(r*o.r-i*o.i,r*o.i+i*o.r);
    }
};
wjmzbmr x1[maxn+50],x2[maxn+50];
void brc(wjmzbmr *y,int l)
{
    for(int i=1,j=l/2;i<l-1;i++)
    {
        if(i<j) swap(y[i],y[j]);
        int k=l/2;
        while(j>=k)j-=k,k/=2;
        if(j<k) j+=k;
    }
}
void fft(wjmzbmr *y,int l,double on)
{
    wjmzbmr u,t;
    brc(y,l);
    for(int h=2;h<=l;h<<=1)
    {
        wjmzbmr wn(cos(on*2*pi/h),sin(on*2*pi/h));
        for(int j=0;j<l;j+=h)
        {
            wjmzbmr w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                u=y[k];
                t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)for(int i=0;i<l;i++) y[i].r/=l;
}
void init(int *a,int n,wjmzbmr *x1,int *b,int m,wjmzbmr *x2)
{
    /*将a[0]~a[n-1]放到x1中，将b[0]~b[m-1]放到x2中*/
    l=1;
    while(l<max(n,m)*2) l<<=1;
    for(int i=0;i<n;++i)
    {
        x1[i].r=a[i];
        x1[i].i=0.0;
    }
    for(int i=n;i<l;++i)x1[i].r=x1[i].i=0.0;
    for(int i=0;i<m;++i)
    {
        x2[i].r=b[i];
        x2[i].i=0.0;
    }
    for(int i=m;i<l;i++) x2[i].r=x2[i].i=0.0;
}
int main()
{
    scanf("%d %d",&n,&m);
    ++n,++m;
    for(int i=0;i<n;++i) scanf("%d",&a[i]);
    for(int i=0;i<m;++i) scanf("%d",&b[i]);
    init(a,n,x1,b,m,x2);
    fft(x1,l,1);
    fft(x2,l,1);
    for(int i=0;i<l;++i) x1[i]=x1[i]*x2[i];
    fft(x1,l,-1);
    for(int i=0;i<n+m-1;++i) printf("%lld ",(long long)(x1[i].r+0.5));
    return 0;
}
```

### 任意模数FFT

注意$M$的取值。最好是$sqrt(mod)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=524300,mod=1e9+7;
int n;
int A[maxn+5],B[maxn+5],C[maxn+5];
int len;
int pos[maxn+5];
namespace FFT
{
    /*
    模任意质数mod的FFT
    */
    int M=1000;
    struct comp
    {
        long double r,i;
        comp(long double _r=0,long double _i=0){r=_r;i=_i;}
        comp operator+(const comp x){return comp(r+x.r,i+x.i);}
        comp operator-(const comp x){return comp(r-x.r,i-x.i);}
        comp operator*(const comp x){return comp(r*x.r-i*x.i,r*x.i+i*x.r);}
        comp conj(){return comp(r,-i);}
    }A[maxn+5],B[maxn+5];
    int a0[maxn+5],b0[maxn+5],a1[maxn+5],b1[maxn+5];
    const long double pi=acos(-1.0);
    void FFT(comp a[],int n,int t)
    {
        for(int i=1;i<n;i++)
            if(i<pos[i])swap(a[i],a[pos[i]]);
        for(int d=0;(1<<d)<n;d++)
        {
            int m=1<<d,m2=m<<1;
            long double o=pi*2/m2*t;comp _w(cos(o),sin(o));
            for(int i=0;i<n;i+=m2)
            {
                comp w(1,0);
                for(int j=0;j<m;j++)
                {
                    comp&A=a[i+j+m],&B=a[i+j],t=w*A;
                    A=B-t;B=B+t;w=w*_w;
                }
            }
        }
        if(t==-1)for(int i=0;i<n;i++)a[i].r/=n;
    }
    void mul(int*a,int*b,int*c,int len)
    {//c=a*b
        for(int i=0;i<len;i++)A[i]=comp(a[i],b[i]);
        FFT(A,len,1);
        for(int i=0;i<len;i++)
        {
            int j=(len-i)&(len-1);
            B[i]=(A[i]*A[i]-(A[j]*A[j]).conj())*comp(0,-0.25);
        }
        FFT(B,len,-1);
        for(int i=0;i<len;i++)c[i]=((long long)(B[i].r+0.5))%mod;
    }
    //输入两个多项式，求a*b mod mod，保存在c中，c不能为a或b，长度为0~len-1
    void mulmod(int*a,int*b,int*c,int len)
    {
        for(int i=0;i<len;i++)a0[i]=a[i]/M,b0[i]=b[i]/M;
        mul(a0,b0,a0,len);
        for(int i=0;i<len;i++)
        {
            c[i]=1LL*a0[i]*M*M%mod;
            a1[i]=a[i]%M,b1[i]=b[i]%M;
        }
        mul(a1,b1,a1,len);
        for(int i=0;i<len;i++)
        {
            c[i]=(a1[i]+c[i])%mod,a0[i]=(a0[i]+a1[i])%mod;
            a1[i]=a[i]/M+a[i]%M,b1[i]=b[i]/M+b[i]%M;
        }
        mul(a1,b1,a1,len);
        for(int i=0;i<len;i++)c[i]=(1LL*M*(a1[i]-a0[i]+mod)+c[i])%mod;
    }
}
int main()
{
    FFT::M=sqrt(mod);
    for(len=1;len<=n;len<<=1);len<<=1;
    int x=__builtin_ctz(len)-1;
    for(int i=0;i<len;i++)pos[i]=pos[i>>1]>>1|((i&1)<<x);
    for(int i=2;i<=n;i++) A[i]=1LL*pa[n-i]*inv[n-i]%mod;
    for(int i=2;i<=n;i++) B[i]=1LL*pb[n-i]*inv[n-i]%mod;
    FFT::mulmod(A,B,C,len);
    return 0;
}
```



### NTT



```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=262144*4;
//const long long P=50000000001507329LL; // 190734863287 * 2 ^ 18 + 1
//const int P=1004535809; // 479 * 2 ^ 21 + 1
const ll mod=998244353; // 119 * 2 ^ 23 + 1
const ll G=3;

ll len=0;
ll pw[maxn+5],pwinv[maxn+5];
ll A[maxn+5],B[maxn+5];
ll f[maxn+5];
int n,m;

ll Pow(ll a,ll b,ll mod)
{
    ll ans=1;
    while(b)
    {
        if(b&1) ans=ans*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}
ll Inv(ll x)
{
    return Pow(x,mod-2,mod);
}
void Init()
{
    ll inv=Inv(G);
    for (int i=1;i<=maxn;i<<=1)
    {
        pw[i]=Pow(G,(mod-1)/i,mod);
        pwinv[i]=Pow(inv,(mod-1)/i,mod);
    }
}
void rader(ll *a)
{
    for(int i=0,j=0;i<len;i++)
    {
        if(i>j) swap(a[i],a[j]);
        int k=len;
        do{k>>=1;j^=k;}while(j<k);
    }
}
void ntt(ll *a,int f)
{
    rader(a);
    for(int i=2;i<=len;i<<=1)
    {
        int m=i>>1;
        for(int j=0;j<len;j+=i)
        {
            ll w=1,wn=pw[i];
            if(f==-1) wn=pwinv[i];
            for(int k=0;k<m;k++)
            {
                ll x=a[j+k+m]*w%mod;
                a[j+k+m]=(a[j+k]-x+mod)%mod;
                a[j+k]=(a[j+k]+x)%mod;
                w=w*wn%mod;
            }
        }
    }
    if(f==-1)
    {
        ll inv=Inv(len);
        for(int i=0;i<len;i++) a[i]=a[i]*inv%mod;
    }
}
void con(ll *A,int n,ll *B,int m)
{
    /*A[0..n-1]与B[0..m-1]卷积*/
    for(len=1;len<max(n,m);len<<=1);
    len<<=1;
    for(int i=n;i<len;++i) A[i]=0;
    for(int i=m;i<len;++i) B[i]=0;
    ntt(A,1);
    ntt(B,1);
    for(int i=0;i<len;++i) A[i]=A[i]*B[i]%mod;
    ntt(A,-1);
}
int main()
{
    Init();
    con(A,n,B,m);
    return 0;
}
```



### FWT

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1024,mod=1e9+7,rev=(mod+1)>>1;
int a[maxn+50],b[maxn+50];
long long fc[maxn*maxn];
int T,n,m;
void fwt(int *a,int n)
{
    for(int d=1;d<n;d<<=1)
        for(int m=d<<1,i=0;i<n;i+=m)
            for(int j=0;j<d;j++)
            {
                int x=a[i+j],y=a[i+j+d];
                a[i+j]=(x+y)%mod,a[i+j+d]=(x-y+mod)%mod;
                //xor:a[i+j]=x+y,a[i+j+d]=(x-y+mod)%mod;
                //and:a[i+j]=x+y;
                //or:a[i+j+d]=x+y;
            }
}
void ufwt(int *a,int n)
{
    for(int d=1;d<n;d<<=1)
        for(int m=d<<1,i=0;i<n;i+=m)
            for(int j=0;j<d;j++)
            {
                int x=a[i+j],y=a[i+j+d];
                a[i+j]=1LL*(x+y)*rev%mod,a[i+j+d]=(1LL*(x-y)*rev%mod+mod)%mod;
                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;
                //and:a[i+j]=x-y;
                //or:a[i+j+d]=y-x;
            }
}
void solve(int *a,int *b,int n)//下标0..n-1的数组a和b求异或卷积，O(nlogn)，返回值在a中
{
    fwt(a,n);
    fwt(b,n);
    for(int i=0;i<n;++i) a[i]=1LL*a[i]*b[i]%mod;
    ufwt(a,n);
}
int main()
{
    fc[0]=1;
    for(int i=1;i<=1000000;++i) fc[i]=fc[i-1]*i%mod;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&n,&m);
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        for(int i=1;i<=n;++i) a[i]=1;
        for(int i=1;i<=m;++i) b[i]=1;
        solve(a,b,maxn);
        long long ans=1;
        for(int i=0;i<maxn;++i) ans=ans*fc[a[i]]%mod;
        printf("%lld\n",ans);
    }
    return 0;
}
```

### 子集卷积

$ans[k]=\sum_{i|j=k \ and \ i\&j=0} A[i]*B[j]$

可以多开一个维度表示元素个数，那么$c[i+j][mask_{i+j}]=\sum_{mask_i|mask_j=mask_{i+j}} a[i][mask_i]*b[j][mask_j]$

```
a[popcount(x)][x] = A[x]
b[popcount(x)][x] = B[x]
fwt(a[i]) fwt(b[i])
c[i + j][x] += a[i][x] * b[j][x]
rfwt(c[i])
ans[x] = c[popcount(x)][x]
```

### 循环卷积

考虑$A[0..n-1]$与$B[0..n-1]$循环卷积：

$A(\omega _n^k)=\sum_{i=0}^{n-1}a_iw_n^{ik},B(\omega _n^k)=\sum_{i=0}^{n-1}b_iw_n^{ik}$

$C(\omega_n^k)=\sum_{i=0}^{n-1}a_iw_n^{ik}\sum_{j=0}^{n-1}b_jw_n^{jk}$

因为有$\omega_n^{ik}·\omega_n^{jk}=\omega_n^{k·(i+j)}=\omega_n^{k·((i+j)mod\,n)}$

所以$C(w_n^k)=\sum_{(i+j\,mod \,n)=l}A_lw_n^{kl}$

其中$A_l={a_i·b_j(i+j \mod n =l)}$

这明显是个$DFT$形式，也就是说我们求出$A$在每个单位根处的点值，求出$B$在每个单位根处的点值，然后再乘起来，然后再$IDFT$就能得到循环卷积的结果。

对于$n$是$2^k$的情况，我们可以直接$FFT$或者$NTT$，但是若$n$不是$2^k$，我们只能采用任意长度$DFT$算法。

主要思想就是$\omega_n^{ik}=\omega_n^{-\frac{(i-k)^2}{2}+\frac{i^2}{2}+\frac{k^2}{2}}$

### BM算法(模数只能是质数)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

ll n;
namespace linear_seq {
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];

    vector<int> Md;
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
//        printf("%d\n",SZ(b));
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        //c是递推式
        //cout<<SZ(c)<<endl;
        //for(int i=0;i<SZ(c);++i) cout<<c[i]<<" ";cout<<endl;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};
vector<int> a;
int main() {
    int T;
    scanf("%d",&T);
    a.clear();
    a.pb(31),a.pb(197),a.pb(1255),a.pb(7997),a.pb(50959),a.pb(324725);
    while(T--)
    {
        scanf("%lld",&n);
        printf("%d\n",linear_seq::gao(a,n-1));
    }
    return 0;
}
```



### k^2logn求线性递推

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
namespace LR
{
    //maxn是递推阶数的2倍
    const ll maxn=4000;
    ll a[maxn+5],p[maxn+5],ans[maxn+5],num[maxn+5];
    ll h[maxn+5],tmp[maxn+5];
    ll n;  //求第n项的值
    int k;  //递推阶数
    void mul(ll *a,ll *b,ll *ans)
    {
        for(int i=0;i<=2*k;++i) tmp[i]=0;
        for(int i=0;i<k;++i)
            for(int j=0;j<k;++j)
                tmp[i+j]=(tmp[i+j]+a[i]*b[j])%mod;
        for(int i=2*k-2;i>=k;--i)
        {
            for(int j=k-1;j>=0;--j)
                tmp[i-k+j]=(tmp[i-k+j]-tmp[i]*p[j])%mod,tmp[i-k+j]=(tmp[i-k+j]+mod)%mod;
            tmp[i]=0;
        }
        for(int i=0;i<k;++i) ans[i]=tmp[i];
    }
    ll solve(ll _n,vector<int> A,vector<int> B) //a系数，b初值，b[n+1]=a[0]*b[n]+...
    {
        n=_n;
        assert(A.size()==B.size());
        k=A.size();
        if(k==1) //k==1特判
        {
            return B[0]*powmod(A[0],n)%mod;
        }
        for(int i=1;i<=k;++i) a[i]=A[i-1];
        for(int i=0;i<k;++i) h[i]=B[i];
        for(int i=k;i<2*k;++i) h[i]=0;
        p[k]=1;
        for(int i=1;i<=k;++i) p[k-i]=mod-a[i];
        for(int i=k;i<2*k;++i)
            for(int j=1;j<=k;++j)
            {
                h[i]=h[i]+h[i-j]*a[j]%mod;
                h[i]%=mod;
            }
        if(n<2*k) return h[n];
        ll b=n-k+1;
        for(int i=0;i<=k;++i) num[i]=ans[i]=0;
        num[1]=1,ans[0]=1;
        while(b)
        {
            if(b&1) mul(ans,num,ans);
            mul(num,num,num);
            b>>=1;
        }
        ll res=0;
        for(int i=0;i<k;++i) res=(res+ans[i]*h[i+k-1])%mod;
        res=(res+mod)%mod;
        return res;
    }
};
```





### lagrange插值

```cpp
void mul(int *a,int d,int c)
{
    /*
    a*(x-c)
    */
    int b[maxn+5];
   // memset(b,0,sizeof(b));
    for(int i=0;i<=d;++i) b[i]=a[i];
    for(int i=d+1;i>=1;--i) a[i]=a[i-1];
    a[0]=0;
    for(int i=0;i<=d;++i)
    {
        a[i]=(a[i]-1LL*b[i]*c)%mod;
        if(a[i]<0) a[i]+=mod;
    }
}
void div(int *a,int d,int c,int *ans)
{
    /*
    ans=a/(x-c)
    */
    ans[d-1]=a[d];
    for(int i=d-2;i>=0;--i)
        ans[i]=(a[i+1]+1LL*c*ans[i+1])%mod;
}
void lagrange(int *y,int d,int *p)
{
    /*
    (0,y[0]),(1,y[1]),...,(d,y[d])
    插出的系数放p中
    */
    int tmp[maxn+5],now[maxn+5];
    memset(tmp,0,sizeof(tmp));
    memset(now,0,sizeof(now));
    tmp[0]=1;
    for(int i=0;i<=d;++i)
    {
        mul(tmp,i,i);
    }
    for(int i=0;i<=d;++i)
    {
        for(int j=0;j<=d;++j) now[j]=0;
        div(tmp,d+1,i,now);
        long long q=1;
        for(int j=0;j<=d;++j)
            if(i!=j)
            {
                q=q*(i-j)%mod;
                if(q<0) q+=mod;
            }
        q=inv(q);
        q=q*y[i]%mod;
        for(int j=0;j<=d;++j) now[j]=1LL*now[j]*q%mod;
        for(int j=0;j<=d;++j) p[j]=(p[j]+now[j])%mod;
    }
}
```

### 线性基求交

```cpp
typedef int Base[32];
void merge(Base A, Base B, Base to)
{
    // calculate the intersection of A and B
    Base tot, na;
    memcpy(tot,A,sizeof(Base));
    memcpy(na,A,sizeof(Base));
    memset(to,0,sizeof(Base));
    int cur,d;
    for(int i=0;i<32;++i)
        if(B[i])
        {
            cur=0,d=B[i];
            for(int j=i;j>=0;--j)
                if(d>>j&1)
                    if(tot[j])
                    {
                        d^=tot[j],cur^=na[j];
                        if(d==0)
                        {
                            to[i]=cur;
                            break;
                        }
                    }
                    else
                    {
                        tot[j] = d;
                        na[j] = cur;
                        break;
                    }
        }
}
```



### 高斯消元

```cpp
/*
n个未知数，m个方程
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000;
const double eps=1e-6;
double a[maxn+5][maxn+5];
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n+1;++j)
            scanf("%lf",&a[i][j]);
    for(int i=1;i<=n;++i)//枚举列
    {
        if(fabs(a[i][i]-0.0)<=eps)
        {
            int j;
            bool flag=0;
            for(j=i+1;j<=m;++j)
                if(fabs(a[j][i]-0.0)>eps)
                {
                    flag=1;
                    break;
                }
            if(!flag) return 0*printf("Many solutions");//如果第i~m行的第i列都是0，那么多解
            for(int k=1;k<=n+1;++k) swap(a[i][k],a[j][k]);
        }
        for(int j=1;j<=n+1;++j) if(i!=j)a[i][j]/=a[i][i];a[i][i]=1.0;
        for(int j=1;j<=m;++j)
            if(j!=i)
            {
                for(int k=1;k<=n+1;++k) if(k!=i) a[j][k]-=a[i][k]*a[j][i];a[j][i]=0.0;
            }
    }
    for(int i=n+1;i<=m;++i)
        if(fabs(a[i][n+1]-0.0)>eps) return 0*printf("No solutions");//n+1~m这些方程应该所有变量都被消干净了，所以如果不为0，则说明无解
    for(int i=1;i<=n;++i) printf("%d\n",(int)(a[i][n+1]+0.5));
    return 0;
}
```

### 高斯消元(xor版)

```cpp
bool Guass(int N,int M)
{
    //返回值表示是否有解
    //free[x]表示变量x是否是自由变元
    //ansx[x]表示变量x的值，自由变元的值默认是0
   /* for(int i=1;i<=M;++i)
    {
        for(int j=0;j<=N;++j)
            cout<<a[i][j]<<" ";
        cout<<endl;
    }*/
    int i,now;
    for(i=1,now=1;i<=M&&now<=N;++i,++now)
    {
        if(a[i][now]==0)
        {
            int j;
            bool flag=0;
            for(j=i+1;j<=M;++j)
                if(a[j][now])
                {
                    flag=1;
                    break;
                }
            if(!flag)
            {
                free[now]=1;
                --i;
                continue;
            }
            for(int k=0;k<=N;++k) swap(a[i][k],a[j][k]);
        }
        for(int j=1;j<=M;++j)
            if(j!=i&&a[j][now])
            {
                for(int k=0;k<=N;++k) a[j][k]^=a[i][k];
            }
    }
    for(i=i+1;i<=M;++i)
        if(a[i][0]!=0) return false;
    now=1;
    for(int i=1;i<=M;++i)
    {
        while(now<=N&&free[now]) ++now;
        if(now>N) break;
        ansx[now]=a[i][0];
        ++now;
    }
    for(int i=1;i<=N;++i) if(free[i]) ansx[i]=0;
    return true;
}
```



### 求行列式

```cpp
const int maxn=1000;
ll a[maxn+5][maxn+5];
int turn,n;
void gcd(ll a,ll b,ll &d,ll &x,ll &y)
{
    if(!b) d=a,x=1,y=0;
    else
    {
        ++turn;
        gcd(b,a%b,d,y,x);
        y-=x*(a/b);
    }
}
ll det(ll n)
{
    //求行列式a[0..n-1][0..n-1]
    ll tmp1[maxn+5],tmp2[maxn+5];
    ll ans=1;
    for(int i=0;i<n;++i)
    {
        for(int j=i+1;j<n;++j)
            if(a[j][i]!=0)
            {
                ll A=a[i][i],B=a[j][i],d,x,y;
                turn=0;
                gcd(A,B,d,x,y);
                for(int k=0;k<n;++k) tmp1[k]=a[i][k],tmp2[k]=a[j][k];
                for(int k=0;k<n;++k) a[i][k]=(x*tmp1[k]+y*tmp2[k])%mod;
                A/=d,B/=d;
                if(turn&1) x=B,y=-A,ans=-ans%mod;else x=-B,y=A;
                for(int k=0;k<n;++k) a[j][k]=(x*tmp1[k]+y*tmp2[k])%mod;
            }
        ans=ans*a[i][i]%mod;
    }
    if(ans<0) ans+=mod;
    return ans;
}
```

### 多项式全家桶(dls)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mp make_pair
typedef long long ll;

// Poly
const int mod=998244353;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
inline void add(int &x, int y) {
  x += y;
  if (x >= mod) {
    x -= mod;
  }
}
inline void sub(int &x, int y) {
  x -= y;
  if (x < 0) {
    x += mod;
  }
}
inline int mul(int x, int y) {
  return (long long) x * y % mod;
}
inline int power(int x, int y) {
  int res = 1;
  for (; y; y >>= 1, x = mul(x, x)) {
    if (y & 1) {
      res = mul(res, x);
    }
  }
  return res;
}
inline int inv(int a) {
  a %= mod;
  if (a < 0) {
    a += mod;
  }
  int b = mod, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a;
    swap(a, b);
    u -= t * v;
    swap(u, v);
  }
  if (u < 0) {
    u += mod;
  }
  return u;
}
namespace ntt
{
    int base = 1, root = -1, max_base = -1;
    vector<int> rev = {0, 1}, roots = {0, 1};
    void init()
    {
      int temp = mod - 1;
      max_base = 0;
      while (temp % 2 == 0) {
        temp >>= 1;
        ++max_base;
      }
      root = 2;
      while (true) {
        if (power(root, 1 << max_base) == 1 && power(root, 1 << max_base - 1) != 1) {
          break;
        }
        ++root;
      }
    }
    void ensure_base(int nbase)
    {
      if (max_base == -1) {
        init();
      }
      if (nbase <= base) {
        return;
      }
      assert(nbase <= max_base);
      rev.resize(1 << nbase);
      for (int i = 0; i < 1 << nbase; ++i) {
        rev[i] = rev[i >> 1] >> 1 | (i & 1) << nbase - 1;
      }
      roots.resize(1 << nbase);
      while (base < nbase) {
        int z = power(root, 1 << max_base - 1 - base);
        for (int i = 1 << base - 1; i < 1 << base; ++i) {
          roots[i << 1] = roots[i];
          roots[i << 1 | 1] = mul(roots[i], z);
        }
        ++base;
      }
    }
    void dft(vector<int> &a)
    {
      int n = a.size(), zeros = __builtin_ctz(n);
      ensure_base(zeros);
      int shift = base - zeros;
      for (int i = 0; i < n; ++i) {
        if (i < rev[i] >> shift) {
          swap(a[i], a[rev[i] >> shift]);
        }
      }
      for (int i = 1; i < n; i <<= 1) {
        for (int j = 0; j < n; j += i << 1) {
          for (int k = 0; k < i; ++k) {
            int x = a[j + k], y = mul(a[j + k + i], roots[i + k]);
            a[j + k] = (x + y) % mod;
            a[j + k + i] = (x + mod - y) % mod;
          }
        }
      }
    }
    vector<int> multiply(vector<int> a, vector<int> b)
    {
      int need = a.size() + b.size() - 1, nbase = 0;
      while (1 << nbase < need) {
        ++nbase;
      }
      ensure_base(nbase);
      int sz = 1 << nbase;
      a.resize(sz);
      b.resize(sz);
      bool equal = a == b;
      dft(a);
      if (equal) {
        b = a;
      } else {
        dft(b);
      }
      int inv_sz = inv(sz);
      for (int i = 0; i < sz; ++i) {
        a[i] = mul(mul(a[i], b[i]), inv_sz);
      }
      reverse(a.begin() + 1, a.end());
      dft(a);
      a.resize(need);
      return a;
    }
    vector<int> faq(vector<int> a, int m)
    {
      int need = (a.size() -1)*m+1, nbase = 0;
      while (1 << nbase < need) {
        ++nbase;
      }
      ensure_base(nbase);
      int sz = 1 << nbase;
      a.resize(sz);
      dft(a);
      int inv_sz = inv(sz);
      for (int i = 0; i < sz; ++i) {
        a[i] = mul(powmod(a[i], m), inv_sz);
      }
      reverse(a.begin() + 1, a.end());
      dft(a);
      a.resize(need);
      return a;
    }
    vector<int> inverse(vector<int> a)
    {
        //A(x)*B(x) = 1 (mod x^n) , B(x) is A(x)'s inverse
      int n = a.size(), m = n + 1 >> 1;
      if (n == 1) {
        return vector<int>(1, inv(a[0]));
      } else {
        vector<int> b = inverse(vector<int>(a.begin(), a.begin() + m));
        int need = n << 1, nbase = 0;
        while (1 << nbase < need) {
          ++nbase;
        }
        ensure_base(nbase);
        int sz = 1 << nbase;
        a.resize(sz);
        b.resize(sz);
        dft(a);
        dft(b);
        int inv_sz = inv(sz);
        for (int i = 0; i < sz; ++i) {
          a[i] = mul(mul(mod + 2 - mul(a[i], b[i]), b[i]), inv_sz);
        }
        reverse(a.begin() + 1, a.end());
        dft(a);
        a.resize(n);
        return a;
      }
    }
}

using ntt::multiply;
using ntt::inverse;

vector<int>& operator += (vector<int> &a, const vector<int> &b) {
  if (a.size() < b.size()) {
    a.resize(b.size());
  }
  for (int i = 0; i < b.size(); ++i) {
    add(a[i], b[i]);
  }
  return a;
}

vector<int> operator + (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c += b;
}

vector<int>& operator -= (vector<int> &a, const vector<int> &b) {
  if (a.size() < b.size()) {
    a.resize(b.size());
  }
  for (int i = 0; i < b.size(); ++i) {
    sub(a[i], b[i]);
  }
  return a;
}

vector<int> operator - (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c -= b;
}

vector<int>& operator *= (vector<int> &a, const vector<int> &b) {
  if (min(a.size(), b.size()) < 128) {
    vector<int> c = a;
    a.assign(a.size() + b.size() - 1, 0);
    for (int i = 0; i < c.size(); ++i) {
      for (int j = 0; j < b.size(); ++j) {
        add(a[i + j], mul(c[i], b[j]));
      }
    }
  } else {
    a = multiply(a, b);
  }
  return a;
}

vector<int> operator * (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c *= b;
}

vector<int>& operator /= (vector<int> &a, const vector<int> &b) {
  int n = a.size(), m = b.size();
  if (n < m) {
    a.clear();
  } else {
    vector<int> c = b;
    reverse(a.begin(), a.end());
    reverse(c.begin(), c.end());
    c.resize(n - m + 1);
    a *= inverse(c);
    a.erase(a.begin() + n - m + 1, a.end());
    reverse(a.begin(), a.end());
  }
  return a;
}

vector<int> operator / (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c /= b;
}

vector<int>& operator %= (vector<int> &a, const vector<int> &b) {
  int n = a.size(), m = b.size();
  if (n >= m) {
    vector<int> c = (a / b) * b;
    a.resize(m - 1);
    for (int i = 0; i < m - 1; ++i) {
      sub(a[i], c[i]);
    }
  }
  return a;
}

vector<int> operator % (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c %= b;
}

vector<int> derivative(const vector<int> &a) {
    // 求导
  int n = a.size();
  vector<int> b(n - 1);
  for (int i = 1; i < n; ++i) {
    b[i - 1] = mul(a[i], i);
  }
  return b;
}

vector<int> primitive(const vector<int> &a) {
    // 求积分
  int n = a.size();
  vector<int> b(n + 1), invs(n + 1);
  for (int i = 1; i <= n; ++i) {
    invs[i] = i == 1 ? 1 : mul(mod - mod / i, invs[mod % i]);
    b[i] = mul(a[i - 1], invs[i]);
  }
  return b;
}

vector<int> logarithm(const vector<int> &a) {
  vector<int> b = primitive(derivative(a) * inverse(a));
  b.resize(a.size());
  return b;
}

vector<int> exponent(const vector<int> &a) {
  vector<int> b(1, 1);
  while (b.size() < a.size()) {
    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));
    add(c[0], 1);
    vector<int> old_b = b;
    b.resize(b.size() << 1);
    c -= logarithm(b);
    c *= old_b;
    for (int i = b.size() >> 1; i < b.size(); ++i) {
      b[i] = c[i];
    }
  }
  b.resize(a.size());
  return b;
}

vector<int> power(const vector<int> &a, int m) {
    // 多项式快速幂
  int n = a.size(), p = -1;
  vector<int> b(n);
  for (int i = 0; i < n; ++i) {
    if (a[i]) {
      p = i;
      break;
    }
  }
  if (p == -1) {
    b[0] = !m;
    return b;
  }
  if ((long long) m * p >= n) {
    return b;
  }
  int mu = power(a[p], m), di = inv(a[p]);
  vector<int> c(n - m * p);
  for (int i = 0; i < n - m * p; ++i) {
    c[i] = mul(a[i + p], di);
  }
  c = logarithm(c);
  for (int i = 0; i < n - m * p; ++i) {
    c[i] = mul(c[i], m);
  }
  c = exponent(c);
  for (int i = 0; i < n - m * p; ++i) {
    b[i + m * p] = mul(c[i], mu);
  }
  return b;
}

vector<int> sqrt(const vector<int> &a) {
  vector<int> b(1, 1);
  while (b.size() < a.size()) {
    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));
    vector<int> old_b = b;
    b.resize(b.size() << 1);
    c *= inverse(b);
    for (int i = b.size() >> 1; i < b.size(); ++i) {
      b[i] = mul(c[i], mod + 1 >> 1);
    }
  }
  b.resize(a.size());
  return b;
}

vector<int> multiply_all(int l, int r, vector<vector<int>> &all) {
    //分治乘法
  if (l > r) {
    return vector<int>();
  } else if (l == r) {
    return all[l];
  } else {
    int y = l + r >> 1;
    return multiply_all(l, y, all) * multiply_all(y + 1, r, all);
  }
}

vector<int> evaluate(const vector<int> &f, const vector<int> &x) {
    //多点求值 , nlog^2 常数巨大
  int n = x.size();
  if (!n) {
    return vector<int>();
  }
  vector<vector<int>> up(n * 2);
  for (int i = 0; i < n; ++i) {
    up[i + n] = vector<int>{(mod - x[i]) % mod, 1};
  }
  for (int i = n - 1; i; --i) {
    up[i] = up[i << 1] * up[i << 1 | 1];
  }
  vector<vector<int>> down(n * 2);
  down[1] = f % up[1];
  for (int i = 2; i < n * 2; ++i) {
    down[i] = down[i >> 1] % up[i];
  }
  vector<int> y(n);
  for (int i = 0; i < n; ++i) {
    y[i] = down[i + n][0];
  }
  return y;
}

vector<int> interpolate(const vector<int> &x, const vector<int> &y) {
    // 快速插值，nlog^3n 常数巨大
  int n = x.size();
  vector<vector<int>> up(n * 2);
  for (int i = 0; i < n; ++i) {
    up[i + n] = vector<int>{(mod - x[i]) % mod, 1};
  }
  for (int i = n - 1; i; --i) {
    up[i] = up[i << 1] * up[i << 1 | 1];
  }
  vector<int> a = evaluate(derivative(up[1]), x);
  for (int i = 0; i < n; ++i) {
    a[i] = mul(y[i], inv(a[i]));
  }
  vector<vector<int>> down(n * 2);
  for (int i = 0; i < n; ++i) {
    down[i + n] = vector<int>(1, a[i]);
  }
  for (int i = n - 1; i; --i) {
    down[i] = down[i << 1] * up[i << 1 | 1] + down[i << 1 | 1] * up[i << 1];
  }
  return down[1];
}

int n;

int main()
{

	return 0;
}

```



## 其它

### 牛顿迭代

牛顿迭代可以解高次方程的数值解。

```cpp
#include<bits/stdc++.h>
using namespace std;
//解 2p=1+p^(n+1)
double power(double p, int n)
{
    double result = 1;
    for (int i = 0; i < n; ++i)
        result *= p;
    return result;
}

double f(double p, int n)
{
    return power(p, n+1) - 2*p + 1;
}

double derivative(double p, int n)
{
    return (n+1)*power(p, n) - 2;
}

double newton(int n, double p0)
{
    //解 2p=1+p^(n+1) , p0是初值
    double p = p0;
    int max_iteration = 20;
    int counter = 0;
    double eps = 1.0e-14;
    cout.precision(16);
    while(true)
    {
        counter++;
        if (counter > max_iteration)
            break;
        p = p0 - f(p0, n)/derivative(p0, n);
        double error = fabs(p - p0);
        cout << "counter = " << counter << ", error = " << error << ", value = " << p << endl;
        if (error < eps)
            break;
        p0 = p;
    }
    cout << endl;
    return p;
}

int main()
{
    cout<<newton(2,0.1)<<endl;
    return 0;
}
```



## 公式

### 一些数论公式

- 当 $x\geq\phi(p)$ 时有 $a^x\equiv a^{x \ mod \  \phi(p) + \phi(p)}\pmod p$
- $\mu^2(n)=\sum_{d^2|n} \mu(d)$
- $\sum_{d|n} \varphi(d)=n$
- $\sum_{d|n} 2^{\omega(d)}=\sigma_0(n^2)$，其中 $\omega$ 是不同素因子个数，$\sigma_0(x)$是$x$的因子个数
- $\sum_{d|n} \mu^2(d)=2^{\omega(n)}$

### 一些数论函数求和的例子

- $\sum_{i=1}^n i[gcd(i, n)=1] = \frac {n \varphi(n) + [n=1]}{2}$
- $\sum_{i=1}^n \sum_{j=1}^m [gcd(i,j)=x]=\sum_d \mu(d) \lfloor \frac n {dx} \rfloor \lfloor \frac m {dx} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^m gcd(i, j) = \sum_{i=1}^n \sum_{j=1}^m \sum_{d|gcd(i,j)} \varphi(d) = \sum_{d} \varphi(d) \lfloor \frac nd \rfloor \lfloor \frac md \rfloor$
- $S(n)=\sum_{i=1}^n \mu(i)=1-\sum_{i=1}^n \sum_{d|i,d < i}\mu(d) \overset{t=\frac id}{=} 1-\sum_{t=2}^nS(\lfloor \frac nt \rfloor)$
  - 利用 $[n=1] = \sum_{d|n} \mu(d)$
- $S(n)=\sum_{i=1}^n \varphi(i)=\sum_{i=1}^n i-\sum_{i=1}^n \sum_{d|i,d<i} \varphi(i)\overset{t=\frac id}{=} \frac {i(i+1)}{2} - \sum_{t=2}^n S(\frac n t)$
  - 利用 $n = \sum_{d|n} \varphi(d)$
- $\sum_{i=1}^n \mu^2(i) = \sum_{i=1}^n \sum_{d^2|n} \mu(d)=\sum_{d=1}^{\lfloor \sqrt n \rfloor}\mu(d) \lfloor \frac n {d^2} \rfloor$
- $\sum_{i=1}^n \sum_{j=1}^n gcd^2(i, j)= \sum_{d} d^2 \sum_{t} \mu(t) \lfloor \frac n{dt} \rfloor ^2 \ \overset{x=dt}{=} \sum_{x} \lfloor \frac nx \rfloor ^ 2 \sum_{d|x} d^2 \mu(\frac xd)$
- $\sum_{i=1}^n \varphi(i)=\frac 12 \sum_{i=1}^n \sum_{j=1}^n [i \perp j] - 1=\frac 12 \sum_{i=1}^n \mu(i) \cdot\lfloor \frac n i \rfloor ^2-1$

### 斐波那契数列性质

- $F_{a+b}=F_{a-1} \cdot F_b+F_a \cdot F_{b+1}$
- $F_1+F_3+\dots +F_{2n-1} = F_{2n},F_2 + F_4 + \dots + F_{2n} = F_{2n + 1} - 1$
- $\sum_{i=1}^n F_i = F_{n+2} - 1$
- $\sum_{i=1}^n F_i^2 = F_n \cdot F_{n+1}$
- $F_n^2=(-1)^{n-1} + F_{n-1} \cdot F_{n+1}$
- $gcd(F_a, F_b)=F_{gcd(a, b)}$
- 模 $n$ 周期（皮萨诺周期）
  - $\pi(p^k) = p^{k-1} \pi(p)$
  - $\pi(nm) = lcm(\pi(n), \pi(m)), \forall n \perp m$
  - $\pi(2)=3, \pi(5)=20$
  - $\forall p \equiv \pm 1\pmod {10}, \pi(p)|p-1$
  - $\forall p \equiv \pm 2\pmod {5}, \pi(p)|2p+2$