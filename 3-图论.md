[TOC]

# 图论

## 网络流

### 匈牙利算法

求二分图最大匹配，最坏情况下时间复杂度是$O(n^3)$，但一般情况下会是$O(n^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000;
vector<int> g[maxn+5];
bool v[maxn+5];
int f[maxn+5];
int n,m;
void addedge(int u,int v)
{
    g[u].push_back(v);
    g[v].push_back(u);
}
bool dfs(int k)
{
    for(int i=0;i<g[k].size();++i)
        if(v[g[k][i]]==0)
        {
            v[g[k][i]]=1;
            if(f[g[k][i]]==0||dfs(f[g[k][i]]))
            {
                f[g[k][i]]=k;
                f[k]=g[k][i];
                return true;
            }
        }
    return false;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<=n+m;++i) g[i].clear();
    for(int i=n+1;i<=m+n;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        ++x,++y;
        addedge(i,x);
        addedge(i,y);
    }
    memset(f,0,sizeof(f));
    int ans=0;
    for(int i=1;i<=n+m;++i)
    {
        if(f[i]!=0) continue;
        memset(v,0,sizeof(v));
        if(dfs(i)) ++ans;
    }
    printf("%d",ans);
    return 0;
}
```

### 二分图最大独立集/最小点覆盖

```cpp
#include<bits/stdc++.h>
using namespace std;
#define left lsfdlk
const int maxn=5000;
int a[maxn+5];
vector<int> g[maxn+5];
bool inS[maxn+5],inT[maxn+5],ismatch[maxn+5];
bool left[maxn+5];
int f[maxn+5];
int n,m;
void addedge(int u,int v)
{
    g[u].push_back(v);
    g[v].push_back(u);
}
bool dfs(int k)
{
    inS[k]=1;
    for(int i=0;i<g[k].size();++i)
        if(inT[g[k][i]]==0)
        {
            inT[g[k][i]]=1;
            if(f[g[k][i]]==0||dfs(f[g[k][i]]))
            {
                f[g[k][i]]=k;
                f[k]=g[k][i];
                return true;
            }
        }
    return false;
}
int main()
{
    freopen("ce.in","r",stdin);
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    for(int i=1;i<=n;++i)
        for(int j=i+1;j<=n;++j)
            if(__builtin_popcount(a[i]^a[j])==1) addedge(i,j);
    for(int i=1;i<=n;++i)
        if(__builtin_popcount(a[i])&1) left[i]=true;
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;++i)
    {
        if(!left[i]) continue; //只遍历左边点
        memset(inT,0,sizeof(inT));
        if(dfs(i)) ismatch[i]=true;
    }
    memset(inS,0,sizeof(inS));
    memset(inT,0,sizeof(inT));
    for(int i=1;i<=n;++i)
        if(left[i]&&!ismatch[i]) dfs(i);
    vector<int> ans;    //最大独立集
    ans.clear();
    for(int i=1;i<=n;++i)
    {
        if(left[i]&&inS[i]) ans.push_back(a[i]);
        if(!left[i]&&!inT[i]) ans.push_back(a[i]);
    }
    cout<<ans.size()<<endl;
    for(auto x:ans) cout<<x<<" ";
    return 0;
}
```

### 一般图匹配(带花树)

带花树。复杂度$O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500;
int n;
vector<int> G[maxn+5];
int fa[maxn+5], mt[maxn+5], pre[maxn+5], mk[maxn+5];
int lca_clk, lca_mk[maxn+5];
pair<int, int> ce[maxn+5];

void connect(int u, int v)
{
    mt[u] = v;
    mt[v] = u;
}
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }

void flip(int s, int u)
{
    if (s == u) return;
    if (mk[u] == 2)
    {
        int v1 = ce[u].first, v2 = ce[u].second;
        flip(mt[u], v1);
        flip(s, v2);
        connect(v1, v2);
    }
    else
    {
        flip(s, pre[mt[u]]);
        connect(pre[mt[u]], mt[u]);
    }
}

int get_lca(int u, int v)
{
    lca_clk++;
    for (u = find(u), v = find(v); ; u = find(pre[u]), v = find(pre[v]))
    {
        if (u && lca_mk[u] == lca_clk) return u;
        lca_mk[u] = lca_clk;
        if (v && lca_mk[v] == lca_clk) return v;
        lca_mk[v] = lca_clk;
    }
}

void access(int u, int p, const pair<int, int>& c, vector<int>& q)
{
    for (u = find(u); u != p; u = find(pre[u])) {
        if (mk[u] == 2) {
            ce[u] = c;
            q.push_back(u);
        }
        fa[find(u)] = find(p);
    }
}

bool aug(int s)
{
    for(int i=0;i<=n;++i) mk[i]=pre[i]=0;
    for(int i=0;i<=n;++i) fa[i]=i;
	vector<int> q = {s};
	mk[s] = 1;
    int t = 0;
    for (int t = 0; t < (int) q.size(); ++t)
    {
        // q size can be changed
        int u = q[t];
        for (int &v: G[u])
        {
            if (find(v) == find(u)) continue;
            if (!mk[v] && !mt[v])
            {
                flip(s, u);
                connect(u, v);
                return true;
            }
            else if (!mk[v])
            {
                int w = mt[v];
                mk[v] = 2; mk[w] = 1;
                pre[w] = v; pre[v] = u;
                q.push_back(w);
            }
            else if (mk[find(v)] == 1)
            {
                int p = get_lca(u, v);
                access(u, p, {u, v}, q);
                access(v, p, {v, u}, q);
            }
        }
    }
    return false;
}

int match()
{
    for(int i=1;i<=n;++i) mt[i]=0;
    lca_clk = 0;
    int ans = 0;
    for(int i=1;i<=n;++i)
        if (!mt[i]) ans += aug(i);
    return ans;
}

int main()
{
    freopen("ce.in","r",stdin);
    int m;
    cin >> n >> m;
    while (m--)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    printf("%d\n", match());
    for(int i=1;i<n;++i)
        printf("%d ",mt[i]);
    printf("%d\n",mt[n]);
    return 0;
}
```



### KM算法

求二分图最优匹配

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
const int maxn=407,inf=1e9;
int nl,nr,m;
struct KuhnMunkres
{
    int n;//左边1~n个点，右边1~n个点
    int a[maxn+5][maxn+5];
    int lx[maxn+5],ly[maxn+5],sla[maxn+5];//lx是左边顶标  ly是右边顶标
    int fl[maxn+5],fr[maxn+5];//fl[i]表示左边第i个点匹配右边哪个点 fr[i]表示右边第i个点匹配哪个点
    int vx[maxn+5],vy[maxn+5],pre[maxn+5];
    int q[maxn+5],tp;
    void match(int x)
    {
        while(x)
        {
            fr[x]=pre[x];
            int y=fl[fr[x]];
            fl[fr[x]]=x;
            x=y;
        }
    }
    void find(int x)
    {
        fill(vx,vx+n+1,0);
        fill(vy,vy+n+1,0);
        fill(sla,sla+n+1,inf);
        q[tp=1]=x;vx[x]=1;
        while(1)
        {
            for(int i=1;i<=tp;i++)
            {
                int x=q[i];
                for(int y=1;y<=n;y++)
                {
                    int t=lx[x]+ly[y]-a[x][y];
                    if(vy[y]||t>sla[y])continue;
                    pre[y]=x;
                    if(t==0)
                    {
                        if(!fr[y]){match(y);return;}
                        q[++tp]=fr[y];vy[y]=1;vx[fr[y]]=1;
                    }
                    else sla[y]=t;
            }
        }
        int d=inf;tp=0;
        for(int i=1;i<=n;i++)if(!vy[i]&&d>sla[i])d=sla[i],x=i;
        for(int i=1;i<=n;i++)
        {
            if(vx[i])lx[i]-=d;
            if(vy[i])ly[i]+=d;
            else sla[i]-=d;
        }
        if(!fr[x]){match(x);return;}
        q[++tp]=fr[x];vy[x]=vx[fr[x]]=1;
    }
}
    void solve()
    {
        memset(lx,0,sizeof(lx));
        memset(ly,0,sizeof(ly));
        memset(fl,0,sizeof(fl));
        memset(fr,0,sizeof(fr));
        for(int i=1;i<=n;++i) lx[i]=*max_element(a[i]+1,a[i]+n+1);
        for(int i=1;i<=n;++i) find(i);
    }
}km;
int main()
{
    scanf("%d%d%d",&nl,&nr,&m);
    while(m--)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        scanf("%d",&km.a[u][v]);
    }
    km.n=max(nl,nr);
    km.solve();
    long long ans=0;
    for(int i=1;i<=nl;++i)ans+=km.a[i][km.fl[i]];
    printf("%lld\n",ans);
    for(int i=1;i<=nl;++i)
        if(km.a[i][km.fl[i]]==0) printf("0 ");
        else
            printf("%d ",km.fl[i]);
    return 0;
}
```

### Dinic

求最大流，时间复杂度$O(n^2m)$

**注意初始化len=-1**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000,inf=1e9,maxm=90000;
struct Edge
{
    int from,to,cap,flow;
}edge[maxm*2+5];;
vector <int> g[maxn+5];
int step[maxn];//从源点到点x的距离
int iter[maxn];//定点x的第几条边开始有用
int n,m,S,T,len;
void addedge(int from,int to,int cap)
{
    ++len;
    edge[len]={from,to,cap,0};
    g[from].push_back(len);
    ++len;
    edge[len]={to,from,0,0};
    g[to].push_back(len);
}
void bfs(int S)
{
    memset(step,-1,sizeof(step));
    step[S]=0;
    queue<int> q;
    q.push(S);
    while(!q.empty())
    {
        int v=q.front();
        q.pop();
        for(int i=0;i<g[v].size();++i)
        {
            Edge &e=edge[g[v][i]];
            if(e.cap>e.flow&&step[e.to]<0)
            {
                step[e.to]=step[v]+1;
                q.push(e.to);
            }
        }
    }
}
int dfs(int v,int t,int f)
{
    if(v==t) return f;
    for(int &i=iter[v];i<g[v].size();++i)//这里是引用，i++的同时iter也++，其实相当于上个的used，不过不用判断了
    {
        Edge &e=edge[g[v][i]];
        if(e.cap>e.flow&&step[e.to]>step[v])
        {
            int d=dfs(e.to,t,min(e.cap-e.flow,f));
            if(d>0)
            {
                e.flow+=d;
                edge[g[v][i]^1].flow-=d;
                return d;
            }
        }
    }
    return 0;
}
int maxflow(int S,int T)
{
    int flow=0;
    for(;;)
    {
        bfs(S);
        if(step[T]<0) return flow;
        memset(iter,0,sizeof(iter));
        int f;
        while((f=dfs(S,T,inf))>0)
            flow+=f;
    }
}
int main()
{
        scanf("%d%d",&n,&m);
       S=0,T=n+1;
        for(int i=0;i<=T;++i) g[i].clear();
        len=-1;
        for(int i=1;i<=n;++i)
        {
            int x;
            scanf("%d",&x);
            if(x==0) addedge(S,i,1);else addedge(i,T,1);
        }
        for(int i=0;i<m;++i)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            addedge(u,v,1);
            addedge(v,u,1);
        }
        printf("%d\n",maxflow(S,T));
    return 0;
}
```

### 最大费用最大流（spfa实现）

求最大费用最大流，时间复杂度：**增广次数 $\times$ spfa时间复杂度**

这意味着，即使图很大，但费用很小的情况下，也能快速跑完

**注意初始化len=-1**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=200,maxm=5000,inf=1e7;
const double eps=1e-12;
struct wjmzbmr
{
    int from,to,cap,flow;
    double cost;
}edge[8*maxm];
vector<int> g[maxn+50];
double d[maxn+50];
int a[maxn+50],b[maxn+50],last[maxn+50],f[maxn+50];
int n,m,t,len,S,T;
bool v[maxn+50];
void add(int from,int to,int cap,double cost)
{
    edge[++len]=(wjmzbmr){from,to,cap,0,cost},g[from].push_back(len);
    edge[++len]=(wjmzbmr){to,from,0,0,-cost},g[to].push_back(len);
}
bool spfa(int S,int T,int &flow,double &cost)
{
    for(int i=0;i<=n+1;++i) d[i]=(double)-inf,f[i]=inf;
    memset(v,0,sizeof(v));
    d[S]=0.0,v[S]=1,last[S]=0,f[S]=inf;
    queue<int> q;
    while(!q.empty()) q.pop();
    q.push(S);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        v[u]=0;
        for(int i=0;i<g[u].size();++i)
        {
            wjmzbmr& e=edge[g[u][i]];
            if(e.cap>e.flow&&(d[e.to]+eps<d[u]+e.cost))
            {
                d[e.to]=d[u]+e.cost;
                last[e.to]=g[u][i];
                f[e.to]=min(f[u],e.cap-e.flow);
                if(!v[e.to])
                {
                    q.push(e.to);
                    v[e.to]=1;
                }
            }
        }
    }
    if(d[T]==-inf) return false;
    //if(d[T]*f[T]<0) return false;最大费用可行流
    flow+=f[T];
    cost+=d[T]*f[T];
    int u=T;
    while(u!=S)
    {
        edge[last[u]].flow+=f[T];
        edge[last[u]^1].flow-=f[T];
        u=edge[last[u]].from;
    }
    return true;
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d",&n,&m);
        len=-1;
        for(int i=0;i<=n;++i) g[i].clear();
        for(int i=1;i<=n;++i) scanf("%d %d",&a[i],&b[i]);
        for(int i=1;i<=m;++i)
        {
            int x,y,z;double p;
            scanf("%d %d %d %lf",&x,&y,&z,&p);
            p=log2(1.0-p);
            if(z==0) continue;
            else
            {
                add(x,y,1,0);
                add(x,y,z-1,p);
            }
        }
        S=0,T=n+1;
        for(int i=1;i<=n;++i)
        {
            if(a[i]-b[i]==0) continue;
            if(a[i]-b[i]>0) add(S,i,a[i]-b[i],0);
            else add(i,T,b[i]-a[i],0);
        }
        int flow=0;double cost=0.0;
        while(spfa(S,T,flow,cost)) ;
        printf("%.2f\n",1.0-pow(2.0,cost));
    }
    return 0;
}
```

### 最小费用最大流（dijkstra实现）



```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
const int maxn=2000+5,inf=1e9;
pair<int,int> a[maxn+5];
struct edge
{
    int to,cap,flow,cost,rev;
};
vector<edge> g[maxn+5];
struct heapnode
{
    int id,v;
    bool operator < (const heapnode &t) const
    {
        return v>t.v;
    }
};
priority_queue<heapnode> q;
int n,m,S,T,flow,cost;
int h[maxn+5],dis[maxn+5],cur[maxn+5];
bool ins[maxn+5];
void addedge(int from,int to,int cap,int cost)
{
    g[from].push_back({to,cap,0,cost,(int)g[to].size()});
    g[to].push_back({from,0,0,-cost,(int)g[from].size()-1});
}
bool Dijkstra()
{
    for (int i=0;i<=T;++i)
    {
        h[i]=min(h[i]+dis[i],inf);
        dis[i]=i==S?0:inf;
    }
    q.push(heapnode{S,0});
    while (!q.empty())
    {
        heapnode x=q.top();
        q.pop();
        if(x.v>dis[x.id]) continue;
        for(int i=0;i<g[x.id].size();++i)
        {
            edge e=g[x.id][i];
            if(e.cap>e.flow&&x.v+h[x.id]+e.cost-h[e.to]<dis[e.to])
            {
                dis[e.to]=x.v+h[x.id]+e.cost-h[e.to];
                q.push(heapnode{e.to, dis[e.to]});
            }
        }
    }
    return dis[T]<inf;
}
int dfs(int x,int a)
{
    if(x == T) return a;
    int ans = 0;
    ins[x] = 1;
    for(int &i=cur[x];i<g[x].size();++i)
    {
        edge &e=g[x][i];
        if(!ins[e.to]&&dis[x]+h[x]+e.cost-h[e.to]==dis[e.to]&&e.cap>e.flow)
        {
            int now=dfs(e.to,min(a,e.cap-e.flow));
            e.flow += now;
            g[e.to][e.rev].flow-=now;
            ans+=now;
            a-=now;
            if (!a) break;
        }
    }
    ins[x] = 0;
    return ans;
}
int main()
{
    freopen("ce.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d%d",&a[i].first,&a[i].second); // bottle
    for(int i=n+1;i<=n+m;++i) scanf("%d%d",&a[i].first,&a[i].second); // people
    scanf("%d%d",&a[n+m+1].first,&a[n+m+1].second);
    S=0,T=n+m+2;
    for(int i=n+1;i<=n+m;++i) addedge(S,i,1,0);
    addedge(S,n+m+1,n-1,0);
    for(int i=1;i<=n;++i) addedge(i,T,1,0);
    for(int i=n+1;i<=n+m+1;++i)
        for(int j=1;j<=n;++j)
            addedge(i,j,1,abs(a[i].first-a[j].first)+abs(a[i].second-a[j].second));
    while(Dijkstra())
    {
        memset(cur,0,sizeof(cur));
        int now=dfs(S,inf);
        flow+=now;
        cost+=now*(dis[T]+h[T]-h[S]);
    }
    for(int i=1;i<=n;++i) cost+=abs(a[i].first-a[n+m+1].first)+abs(a[i].second-a[n+m+1].second);
    printf("%d",cost);
    return 0;
}
```

### 带下界网络流

- 无源汇可行流：$u \rightarrow v$ 边容量为 $[l,r]$，连容量 $r-l$，虚拟源点$S'$到 $v$ 连 $l$，$u$ 到虚拟汇点$T'$连 $l$。
- 有源汇可行流：为了让流能循环使用，连 $T \rightarrow S$，容量 $\infty$。
- 有源汇最大流：跑完可行流后，加 $S' \rightarrow S$，$T \rightarrow T'$，$S$到$T$的最大流就是答案（$T \rightarrow S$ 的流量自动退回去了，这一部分就是下界部分的流量）。
- 有源汇最小流：$T$ 到 $S$ 的那条边的实际流量，减去删掉那条边后 $T$ 到 $S$ 的最大流。
- 注意当原图中$T$到$S$本身有边的时候，需要把边合并。
- 费用流：必要的部分（下界以下的）不要钱，剩下的按照最大流。



## 连通分量

### 有向图

#### 两次DFS

时间复杂度$O(n+m)$

可用bitset优化

```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=1e5,inf=1e9;
vector < int > g[maxn+50],g1[maxn+50],g2[maxn+50];
bool v[maxn+50];
int n,m,color[maxn+50],t[maxn+50],len,c,d[maxn+50];
void dfs(int k)
{
    v[k]=1;
    for(int i=0;i<g[k].size();++i)
        if(!v[g[k][i]]) dfs(g[k][i]);
    ++len;
    t[len]=k;
}
void dfs1(int k)
{
    v[k]=1;
    color[k]=c;
    for(int i=0;i<g1[k].size();++i)
        if(!v[g1[k][i]]) dfs1(g1[k][i]);
}
bool check2(int a,int b)
{
    if(a==b) return 0;
    for(int i=0;i<g2[a].size();++i)
        if(g2[a][i]==b) return 0;
    return 1;
}
int main()
{

    while(scanf("%d %d",&n,&m)!=EOF)
    {
        c=0;
        len=0;
        memset(d,0,sizeof(d));
    for(int i=0;i<=n;++i) g[i].clear(),g1[i].clear(),g2[i].clear();
    for(int i=1;i<=m;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        g[x].push_back(y);
        g1[y].push_back(x);
    }
    memset(v,0,sizeof(v));
    memset(t,0,sizeof(t));
    for(int i=1;i<=n;++i) if(!v[i]) dfs(i);
    memset(v,0,sizeof(v));
    for(int i=len;i>=1;--i) if(!v[t[i]]) ++c,dfs1(t[i]);
    for(int i=1;i<=n;++i)
        for(int j=0;j<g[i].size();++j)
            if(check2(color[i],color[g[i][j]]))
                g2[color[i]].push_back(color[g[i][j]]),++d[color[i]];
    int s=0,x=0;
    for(int i=1;i<=c;++i) if(d[i]==0) ++s,x=i;
    if(s>1) printf("0\n");
    else
    {
        int ans=0;
        for(int i=1;i<=n;++i)
            if(color[i]==x) ++ans;
        printf("%d\n",ans);
    }
    }
    return 0;
}
/*bitset优化*/
void dfs(int k)
{
    if(vis[k]==0) return;
    vis.reset(k);
    bitset<maxn+5> nx=vis&g[k];
    int u=nx._Find_first();
    while(u<=n)
    {
        dfs(u);
        u=nx._Find_next(u);
    }
    a.push_back(k);
}
void dfs1(int k)
{
    if(vis[k]==0) return;
    vis.reset(k);
    bitset<maxn+5> nx=vis&g1[k];
    int u=nx._Find_first();
    while(u<=n)
    {
        dfs1(u);
        u=nx._Find_next(u);
    }
}
```

### 无向图(Tarjan)

#### 点双

注意一个点可能会出现在多个点双里面

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000,maxm=1000000;
vector<int> g[maxn+50],bcc[maxn+50];
int dfstime[maxn+50],low[maxn+50],color[maxn+50],head[maxn+50];
bool p[maxn+5][maxn+5],map[maxn+5][maxn+5],flag;
int n,m,top,c,t;
bool ins[maxn+50];
struct wjmzbmr
{
    int u,v;
}s[maxm];
void tarjan(int k,int fa)
{
    low[k]=dfstime[k]=++t;
    for(int i=0;i<g[k].size();++i)
    {
        int u=g[k][i];
        if(u==fa) continue;
        if(dfstime[u])
            if(dfstime[u]<dfstime[k]) low[k]=min(low[k],dfstime[u]),s[++top]={k,u};
            else;
        else
        {
            s[++top]={k,u};
            tarjan(u,k);
            low[k]=min(low[k],low[u]);
            if(low[u]>=dfstime[k])
            {
                ++c;
                while(1)
                {
                    wjmzbmr e=s[top--];
                    if(color[e.u]!=c)
                    {
                        bcc[c].push_back(e.u);
                        color[e.u]=c;
                    }
                    if(color[e.v]!=c)
                    {
                        bcc[c].push_back(e.v);
                        color[e.v]=c;
                    }
                    if(e.u==k&&e.v==u) break;
                }
            }
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    while(!(n==0&&m==0))
    {
        for(int i=0;i<=n;++i) g[i].clear(),bcc[i].clear();
        memset(p,0,sizeof(p));
        for(int i=1;i<=m;++i)
        {
            int x,y;
            scanf("%d %d",&x,&y);
            p[x][y]=p[y][x]=1;
        }
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                if(i!=j&&!p[i][j]) g[i].push_back(j);
        memset(dfstime,0,sizeof(dfstime));
        memset(s,0,sizeof(s));
        memset(color,0,sizeof(color));
        top=c=t=0;
        for(int i=1;i<=n;++i)
            if(!dfstime[i]) tarjan(i,-1);
        scanf("%d %d",&n,&m);
    }
    return 0;
}
```

#### 边双

时间复杂度$O(n+m)$

一个点只会出现在一个边双里，桥隔开了所有的边双

```cpp
#include<bits\stdc++.h>
using namespace std;
const int maxn=4e5;
struct wjmzbmr
{
    int x,y,pos;
};
wjmzbmr e[2*maxn+50];
vector<int> g[maxn+50];
int dfstime[maxn+50],low[maxn+50],s[maxn+50],color[maxn+50],num[maxn+50];
int n,m,top,c,t,ans1=0;
bool ins[maxn+50];
void tarjan(int k,int fa)
{
    low[k]=dfstime[k]=++t;
    s[++top]=k;
    ins[k]=1;
    for(int i=0;i<g[k].size();++i)
    {
        int u=e[g[k][i]].y;
        if(fa==u) continue;
        if(!dfstime[u])
        {
            tarjan(u,k);
            //if(low[u]>dfstime[k]) p[g[k][i]]=1; 判断此边是否为桥
            low[k]=min(low[k],low[u]);
        }
        else
            if(ins[u]) low[k]=min(low[k],low[u]);
    }
    if(dfstime[k]==low[k])
    {
        ++c;
        while(1)
        {
            int v=s[top--];
            ins[v]=0,color[v]=c,++num[c];
            if(v==k) break;
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<=n;++i) g[i].clear();
    for(int i=1;i<=m;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        g[x].push_back(2*i-1),g[y].push_back(2*i);
        e[2*i-1]={x,y,i},e[2*i]={y,x,i};
    }
    memset(dfstime,0,sizeof(dfstime));
    for(int i=1;i<=n;++i) low[i]=n+1;
    memset(color,0,sizeof(color));
    memset(num,0,sizeof(num));
    memset(s,0,sizeof(s));
    memset(ins,0,sizeof(ins));
    top=c=t=0;
    tarjan(1,-1);
    return 0;
}
```

## 三元环、四元环

### 三元环

将点分成度入小于 $\sqrt{m}$ 和超过 $\sqrt{m}$ 的两类。现求包含第一类点的三元环个数。由于边数较少，直接枚举两条边即可。由于一个点度数不超过 $\sqrt{m}$，所以一条边最多被枚举 $\sqrt{m}$ 次，复杂度 $O(m \sqrt{m})$。再求不包含第一类点的三元环个数，由于这样的点不超过 $\sqrt{m}$ 个，所以复杂度也是 $O(m \sqrt{m})$。

对于每条无向边 $(u,v)$，如果 $d_u < d_v$，那么连有向边 $(u,v)$，否则有向边 $(v,u)$。度数相等的按第二关键字判断。然后枚举每个点 $x$，假设 $x$ 是三元组中度数最小的点，然后暴力往后面枚举两条边找到 $y$，判断 $(x,y)$ 是否有边即可。复杂度也是 $O(m \sqrt{m})$。

```cpp
int cycle3() 
{
    int ans = 0;
    for (Edge &e: edges) { deg[e.u]++; deg[e.v]++; }
    for (Edge &e: edges) 
    {
        if (deg[e.u] < deg[e.v] || (deg[e.u] == deg[e.v] && e.u < e.v))
            G[e.u].push_back(e.v);
        else G[e.v].push_back(e.u);
    }
    for(int x=1;x<=n;++x)
    {
        for (int y: G[x]) p[y] = x;
        for (int y: G[x]) 
            for (int z: G[y]) 
                if (p[z] == x) ans++;
    }
    return ans;
}
```

### 四元环

考虑这样一个四元环，将答案统计在度数最大的点 $b$ 上。考虑枚举点 $u$，然后枚举与其相邻的点 $v$，然后再枚举所有度数比 $v$ 大的与 $v$ 相邻的点，这些点显然都可能作为 $b$ 点，我们维护一个计数器来计算之前 $b$ 被枚举多少次，答案加上计数器的值，然后计数器加一。

枚举完 $u$ 之后，我们用和枚举时一样的方法来清空计数器就好了。

任何一个点，与其直接相连的度数大于等于它的点最多只有 $\sqrt{2m}$ 个。所以复杂度 $O(m \sqrt{m})$。

```cpp
ll cycle4() {
    ll ans = 0;
    for(int i=0;i<=n;++i) kth[i]=i;
    sort(kth+1, kth + n+1, [&](int x, int y) { return deg[x] < deg[y]; });
   	for(int i=1;i<=n;++i) rk[kth[i]] = i;
    for(int i=1;i<=n;++i)
        for (int v: G[u])
            if (rk[v] > rk[u]) key[u].push_back(v);
    for(int i=1;i<=n;++i)
    {
        for (int v: G[u])
            for (int w: key[v])
                if (rk[w] > rk[u]) ans += cnt[w]++;
        for (int v: G[u])
            for (int w: key[v])
                if (rk[w] > rk[u]) --cnt[w];
    }
    return ans;
}
```



## 图的非递归遍历

```cpp
void dfs(int k,int last)
{
   /* L[k]=++t;
    deep[k]=deep[last]+1;
    fa[k][0]=last;
    for(int i=0;i<g[k].size();++i)
        if(g[k][i]!=last) dfs(g[k][i],k);
    R[k]=t;*/
    while(!s.empty()) s.pop();
    memset(head,0,sizeof(head));//head[i]表示第i个点当前遍历到了第几个相邻点
    s.push(0);
    s.push(1);
    while(s.size()>1)
    {
        int k=s.top();
        s.pop();
        int last=s.top();
        s.push(k);
        if(!head[k])
        {
            L[k]=++t;
            deep[k]=deep[last]+1;
            fa[k][0]=last;
        }
        if(head[k]<g[k].size())
            if(g[k][head[k]]==last) ++head[k];
        if(head[k]==g[k].size())
        {
            R[k]=t;
            s.pop();
        }
        else
            s.push(g[k][head[k]++]);
    }
}
```





## 与树有关的算法

### 树上路径交

树上两条路径$A-B$和$C-D$的交路径是$\{ lca(A,C),lca(A,D),lca(B,C),lca(B,D) \}$中深度最深的$2$个点决定的路径。

### 树哈希

```cpp
typedef unsigned long long ull;
const ull base=13331,seed=19260817;

ull gethash(int k,int fa)
{
    ull ans=base;
    for(auto u:g[k])
    {
        if(u==fa) continue;
        ans=ans*(gethash(u,k)^seed);
    }
    return ans;
}
```

树哈希也可以：

$f_{now}=1+\sum f_{son_{now,i}} \times prime(size_{son_{now,i}})$

$f_now=2+3 \times f_{now} + 7 \times prime(size_{now})$

### 支配树

- `semi[x]` 半必经点（就是 $x$ 的祖先 $z$ 中，能不经过 $z$ 和 $x$ 之间的树上的点而到达 $x$ 的点中深度最小的）
- `idom[x]` 最近必经点（就是深度最大的根到 $x$ 的必经点）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
int n,m;
vector<int> G[maxn], rG[maxn];
vector<int> dt[maxn];
namespace dominate_tree
{
    int fa[maxn], idx[maxn], clk, ridx[maxn];
    int c[maxn], best[maxn], semi[maxn], idom[maxn];
    void init(int n)
    {
        clk = 0;
        fill(c, c + n + 1, -1);
        for(int i=1;i<=n;++i) dt[i].clear();
        for(int i=1;i<=n;++i) semi[i] = best[i] = i;
        fill(idx, idx + n + 1, 0);
    }
    void dfs(int u)
    {
        idx[u] = ++clk; ridx[clk] = u;
        for (int& v: G[u]) if (!idx[v]) { fa[v] = u; dfs(v); }
    }
    int fix(int x)
    {
        if (c[x] == -1) return x;
        int &f = c[x], rt = fix(f);
        if (idx[semi[best[x]]] > idx[semi[best[f]]]) best[x] = best[f];
        return f = rt;
    }
    void go(int rt)
    {
        dfs(rt);
        for(int i=clk;i>=2;--i)
        {
            int x = ridx[i], mn = clk + 1;
            for (int& u: rG[x]) {
                if (!idx[u]) continue;  // 可能不能到达所有点
                fix(u); mn = min(mn, idx[semi[best[u]]]);
            }
            c[x] = fa[x];
            dt[semi[x] = ridx[mn]].push_back(x);
            x = ridx[i - 1];
            for (int& u: dt[x]) {
                fix(u);
                if (semi[best[u]] != x) idom[u] = best[u];
                else idom[u] = x;
            }
            dt[x].clear();
        }
        for(int i=2;i<=clk;++i)
        {
            int u = ridx[i];
            if (idom[u] != semi[u]) idom[u] = idom[idom[u]];
            dt[idom[u]].push_back(u);
        }
    }
}
int main()
{
    for(int i=1;i<=m;++i)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        G[u].push_back(v);
        rG[v].push_back(u);
    }
    dominate_tree::init(n);
    dominate_tree::go(1);
    for(int i=1;i<=n;++i)
        for(auto j:dt[i]) cout<<i<<" "<<j<<endl;
    return 0;
}
```

### 树链剖分

```cpp
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<vector>
using namespace std;
const int maxn=30000,inf=1e9;
struct wjmzbmr
{
    int tid,top,size,son,dep,father,v;
}tree[maxn+50];
struct fotile96
{
    int maxnum,sum;
}f[4*maxn+50];
vector<int> g[maxn+50];
int pos[maxn+50];
int n,label=0,q;
void dfs(int x,int fa,int dep)
{
    tree[x]=(wjmzbmr){0,0,1,0,dep,fa,tree[x].v};
    int m=0;
    for(int i=0;i<g[x].size();++i)
        if(g[x][i]!=fa)
        {
            dfs(g[x][i],x,dep+1);
            tree[x].size+=tree[g[x][i]].size;
            if(tree[g[x][i]].size>m) m=tree[g[x][i]].size,tree[x].son=g[x][i];
        }
}
void connect(int x,int top)
{
    tree[x].tid=++label,pos[tree[x].tid]=x;
    tree[x].top=top;
    if(tree[x].son!=0) connect(tree[x].son,top);
    for(int i=0;i<g[x].size();++i)
        if(g[x][i]!=tree[x].father&&g[x][i]!=tree[x].son) connect(g[x][i],g[x][i]);
}
void make(int k,int l,int r)
{
    if(l>r) return;
    if(l==r) f[k].maxnum=f[k].sum=tree[pos[l]].v;
    else
    {
        int mid=(l+r)>>1;
        make(k*2,l,mid);
        make(k*2+1,mid+1,r);
    f[k].sum=f[k*2].sum+f[k*2+1].sum;
    f[k].maxnum=max(f[k*2].maxnum,f[k*2+1].maxnum);
    }
}
void change(int k,int l,int r,int x,int y)
{
    if(l>r||r<x||l>x) return;
    if(l==r)
    {
        if(l==x) f[k].maxnum=y,f[k].sum=y;
        return;
    }
    int mid=(l+r)>>1;
    change(k*2,l,mid,x,y);
    change(k*2+1,mid+1,r,x,y);
    f[k].sum=f[k*2].sum+f[k*2+1].sum;
    f[k].maxnum=max(f[k*2].maxnum,f[k*2+1].maxnum);
}
int qqmax(int k,int l,int r,int ll,int rr)
{
    if(l>r||l>rr||r<ll) return -inf;
    if(l>=ll&&r<=rr) return f[k].maxnum;
    int mid=(l+r)>>1;
    return max(qqmax(k*2,l,mid,ll,rr),qqmax(k*2+1,mid+1,r,ll,rr));
}
int qmax(int x,int y)
{
    int ans=-inf;
    while(tree[x].top!=tree[y].top)
    {
        if(tree[tree[x].top].dep<tree[tree[y].top].dep) swap(x,y);
        ans=max(ans,qqmax(1,1,n,tree[tree[x].top].tid,tree[x].tid));
        x=tree[tree[x].top].father;
    }
    if(tree[x].dep>tree[y].dep) swap(x,y);
    ans=max(ans,qqmax(1,1,n,tree[x].tid,tree[y].tid));
    return ans;
}
int qqsum(int k,int l,int r,int ll,int rr)
{
    if(l>r||l>rr||r<ll) return 0;
    if(l>=ll&&r<=rr) return f[k].sum;
    int mid=(l+r)>>1;
    return qqsum(k*2,l,mid,ll,rr)+qqsum(k*2+1,mid+1,r,ll,rr);
}
int qsum(int x,int y)
{
    int ans=0;
    while(tree[x].top!=tree[y].top)
    {
        if(tree[tree[x].top].dep<tree[tree[y].top].dep) swap(x,y);
        ans+=qqsum(1,1,n,tree[tree[x].top].tid,tree[x].tid);
        x=tree[tree[x].top].father;
    }
    if(tree[x].dep>tree[y].dep) swap(x,y);
    ans+=qqsum(1,1,n,tree[x].tid,tree[y].tid);
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) g[i].clear();
    for(int i=1;i<n;++i)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        g[x].push_back(y);
        g[y].push_back(x);
    }
    for(int i=1;i<=n;++i) scanf("%d",&tree[i].v);
    dfs(1,0,0);
    connect(1,1);
    make(1,1,n);
    scanf("%d\n",&q);
    for(int i=1;i<=q;++i)
    {
        int x,y;
        char s[10];
        scanf("%s %d %d\n",s,&x,&y);
        if(s[0]=='C') change(1,1,n,tree[x].tid,y);
        if(s[1]=='M') printf("%d\n",qmax(x,y));
        if(s[1]=='S') printf("%d\n",qsum(x,y));
    }
    return 0;
}
```

### dsu on the tree

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5;
int c[maxn+5],l[maxn+5],r[maxn+5],dfn[maxn+5],son[maxn+5],sz[maxn+5];
ll cnt[maxn+5],sum[maxn+5];
ll mx;
ll ans[maxn+5];
int n,dfstime;
vector<int> g[maxn+5];
void pre(int k,int fa)
{
    sz[k]=1;
    l[k]=++dfstime;
    dfn[dfstime]=k;
    for(auto u:g[k])
    {
        if(u==fa) continue;
        pre(u,k);
        if(sz[u]>sz[son[k]]) son[k]=u;
        sz[k]+=sz[u];
    }
    r[k]=dfstime;
}
void del(int k)
{
    for(int i=l[k];i<=r[k];++i)
    {
        int u=c[dfn[i]];
        sum[cnt[u]]-=u;
        --cnt[u];
        sum[cnt[u]]+=u;
        if(sum[mx]==0) --mx;
    }
}
void ins(int k)
{
    for(int i=l[k];i<=r[k];++i)
    {
        int u=c[dfn[i]];
        sum[cnt[u]]-=u;
        ++cnt[u];
        sum[cnt[u]]+=u;
        mx=max(mx,cnt[u]);
    }
}
void dfs(int k,int fa)
{
    mx=0;
    for(auto u:g[k])
    {
        if(u==fa||u==son[k]) continue;
        dfs(u,k);
        del(u);
    }
    if(son[k]) dfs(son[k],k);
    for(auto u:g[k])
    {
        if(u==fa||u==son[k]) continue;
        ins(u);
    }
    int color=c[k];
    sum[cnt[color]]-=color;
    ++cnt[color];
    sum[cnt[color]]+=color;
    mx=max(mx,cnt[color]);
    ans[k]=sum[mx];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&c[i]);
    for(int i=1;i<n;++i)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        g[x].push_back(y),g[y].push_back(x);
    }
    pre(1,0);
    dfs(1,0);
    for(int i=1;i<=n;++i) printf("%lld ",ans[i]);printf("\n");
    return 0;
}
```

### Link-Cut Tree

```cpp
struct LCT
{
    int ch[maxn+5][2],fa[maxn+5],flip[maxn+5];
    int top;
    int q[maxn+5];
    int mx[maxn+5];
    int s1[maxn+5],s3[maxn+5],sz[maxn+5];//sz 实际子树大小  s1 指向某个点的非偏爱子树的大小和 s3 splay内子树中每个点的s1的和
    void init()
    {
        for(int i=1;i<=n;++i) mx[i]=i,sz[i]=1,s3[i]=s1[i]=flip[i]=fa[i]=ch[i][0]=ch[i][1]=0;
    }
    bool isroot(int x)
    {
        return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
    }
    void update(int x)
    {
        int l=ch[x][0],r=ch[x][1];
        mx[x]=x;
        if(val[mx[l]]>val[mx[x]])mx[x]=mx[l];
        if(val[mx[r]]>val[mx[x]])mx[x]=mx[r];
        sz[x]=s3[r]+s1[x]+1;
        s3[x]=s3[l]+s3[r]+s1[x]+1;
    }
    void pushdown(int x)
    {
        int l=ch[x][0],r=ch[x][1];
        if(flip[x])
        {
            flip[x]^=1;flip[l]^=1;flip[r]^=1;
            swap(ch[x][0],ch[x][1]);
            update(x);
        }
    }
    void rotate(int &x)
    {
        int y=fa[x],z=fa[y],l,r;
        if(ch[y][0]==x) l=0;
        else l=1;
        r=l^1;
        if(!isroot(y))
        {
            if(ch[z][0]==y) ch[z][0]=x;
            else ch[z][1]=x;
        }
        fa[x]=z;fa[y]=x;fa[ch[x][r]]=y;
        ch[y][l]=ch[x][r];ch[x][r]=y;
        update(y);update(x);
    }
    void splay(int &x)
    {
        top=0;
        q[++top]=x;
        for(int i=x;!isroot(i);i=fa[i]) q[++top]=fa[i];
        while(top) pushdown(q[top--]);
        while(!isroot(x))
        {
            int y=fa[x],z=fa[y];
            if(!isroot(y))
            {
                if(ch[y][0]==x^ch[z][0]==y) rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
    }
    void access(int x)
    {
        for(int t=0;x;t=x,x=fa[x])
        {
            splay(x);
            s1[x]+=s3[ch[x][1]];
            ch[x][1]=t;
            s1[x]-=s3[t];
            update(x);
        }
    }
    void makeroot(int x)
    {
        access(x);splay(x);flip[x]^=1;
        pushdown(x);
    }
    bool linked(int x,int y)
    {
        //判断点x和点y是否在一个连通块中
        makeroot(x);access(y);splay(y);
        return x==y||fa[x];
    }
    void link(int x,int y)
    {
        makeroot(x);fa[x]=y;
        access(y),splay(y),s1[y]+=s3[x];
        update(y);
    }
    void cut(int x,int y)
    {
        makeroot(x);access(y);splay(y);
        ch[y][0]=fa[x]=0;
        sz[y]-=s3[x];
        s3[y]-=s3[x];
        update(y);
    }
    int findfather(int root,int x)
    {
        //返回实际树上以root为根，x的父亲
        makeroot(root);
        access(x),splay(x);
        pushdown(x);
        int fa=ch[x][0];
        while(true)
        {
            pushdown(fa);
            if(!ch[fa][1]) break;
            fa=ch[fa][1];
        }
        return fa;

    }
    int querymax(int x,int y)
    {
        makeroot(x);access(y);splay(y);
        return mx[y];
    }
}lct;
```

### 虚树

```cpp
void buildtree()
{
    len=0;
    sort(a+1,a+m+1,cmp);//关键点
    id.clear();//记录出现的关键点
    id.push_back(a[1]);
    s[++len]=a[1];
    for(int i=2;i<=m;i++)
    {
        int x=a[i],f=lca(s[len],x);
        while(deep[f]<deep[s[len]])
        {
            if(deep[f]>=deep[s[len-1]])
            {
                addedge(f,s[len],abs(deep[f]-deep[s[len]]));//虚树addedge(u,v,w)
                len--;
                if(f!=s[len]) s[++len]=f;
                break;
            }
            addedge(s[len-1],s[len],abs(deep[s[len-1]]-deep[s[len]]));
            len--;
        }
        if(s[len]!= x) s[++len]=x;
    }
    while(--len) addedge(s[len],s[len+1],abs(deep[s[len+1]]-deep[s[len]]));
}
```

### 圆方树

把一个环缩成若干个圆点和一个方点。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define mp make_pair
const int maxn=1e5,maxm=2e5;
const ll inf=1e15;
//G是圆方树
vector<int> g[maxn+5],G[maxn*2+5];
int n,m;
struct Edge
{
    int u,v,w;
}edge[maxm*4+5];
int tot;
void addedge(vector<int> *g,int u,int v,int w)
{
    edge[tot++]={u,v,w};
    g[u].push_back(tot-1);
    edge[tot++]={v,u,w};
    g[v].push_back(tot-1);
}
int stk[maxn+5];
bool ring[maxn+5];
int top,nn;
int dfn[maxn+5],dfstime=0;
void build_circle(vector<int> tmp)
{
    ++nn;
    vector<ll> l,r;
    int n=tmp.size();
    l.resize(n+1),r.resize(n+1);
    l.clear(),r.clear();
    l[0]=r[0]=0;
    for(int i=0;i<n-1;++i) l[i+1]=l[i]+edge[tmp[i]].w;
    l[n]=r[n]=0;
    for(int i=n-1;i>=1;--i) r[i]=r[i+1]+edge[tmp[i]].w;
    addedge(G,nn,edge[tmp[0]].u,0);   //方点向环上最上面的点连边
    for(int i=1;i<n;++i) addedge(G,nn,edge[tmp[i]].u,max(l[i],r[i]));   //方点和环上点的边权是环上最长距离
    for(auto id:tmp) ring[edge[id].u]=true;
}
void dfs(int u,int fa)
{
    dfn[u]=++dfstime;
    for(auto id:g[u])
    {
        int v=edge[id].v;
        int w=edge[id].w;
        if(v==fa) continue;
        if(!dfn[v]) 
        {
            stk[++top]=id;
            ring[u]=false;
            dfs(v,u);
            if(!ring[u]) addedge(G,u,v,w);  //添加非环边
            --top;
        }
        else
            if(dfn[v]<dfn[u])
            {
                vector<int> tmp;
                tmp.clear();
                tmp.push_back(id);
                int now=top;
                while(true)
                {
                    tmp.push_back(stk[now]);
                    if(edge[stk[now]].u==v) break;
                    --now;
                }
                std::reverse(tmp.begin(),tmp.end());
                build_circle(tmp);
            }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;++i)
    {
        int u,v,w;
        cin>>u>>v>>w;
        addedge(g,u,v,w);
        ans+=w;
    }
    nn=n;//大于n的是方点
    dfs(1,0);
    return 0;
}
```



### 广义圆方树

每个强连通分量变成一个方点和若干个圆点。与仙人掌上的圆方树不同的是一条边也被作为一个强连通分量。

### 最小树形图

朱刘算法，时间复杂度$O(nm)$。

会更改图中的边。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll inf=1e9;
const int maxn=100+5;
struct Edge
{
    int u,v,w;
};
vector<Edge> edges;
int in[maxn+5], id[maxn+5], pre[maxn+5], vis[maxn+5];
int n,m,r;
ll zl_tree(int rt, int n)
{
    ll ans = 0;
    int v, _n = n;
    while (1)
    {
        for(int i=1;i<=n;++i) in[i]=inf;
        for (auto &e: edges)
            if (e.u != e.v && e.w < in[e.v])
            {
                pre[e.v] = e.u;
                in[e.v] = e.w;
            }
        for(int i=1;i<=n;++i)
            if(i!=rt&&in[i]==inf) return -1;
        int tn = 0;
        for(int i=1;i<=_n;++i) id[i]=vis[i]=-1;
        in[rt] = 0;
        for(int i=1;i<=n;++i)
        {
            ans += in[v = i];
            while (vis[v] != i && id[v] == -1 && v != rt)
            {
                vis[v] = i;
                v = pre[v];
            }
            if (v != rt && id[v] == -1)
            {
                ++tn;
                for (int u = pre[v]; u != v; u = pre[u]) id[u] = tn;
                id[v] = tn;
            }
        }
        if (tn == 0) break;
        for(int i=1;i<=n;++i) if (id[i] == -1) id[i] = ++tn;
        for (int i = 0; i < (int) edges.size(); )
        {
            auto &e = edges[i];
            v = e.v;
            e.u = id[e.u]; e.v = id[e.v];
            if (e.u != e.v) { e.w -= in[v]; i++; }
            else { swap(e, edges.back()); edges.pop_back(); }
        }
        n = tn; rt = id[rt];
    }
    return ans;
}
int main()
{
    cin>>n>>m>>r;
    while(m--)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        edges.push_back((Edge){u,v,w});
    }
    ll ans=zl_tree(r,n);
    cout<<ans<<endl;
    return 0;
}
```



### 点分治

```cpp
int getroot(int u)
{
    static int q[maxn+5],f[maxn+5],mx[maxn+5],sz[maxn+5];
    int t=1;
    q[0]=u;
    f[u]=-1;
    for(int i=0;i<t;++i)
    {
        u=q[i];
        for(auto v:g[u])
            if (!vis[v]&&v!=f[u]) f[q[t++]=v]=u;
        mx[q[i]]=0;
        sz[q[i]]=1;
    }
    for (int i=t-1;i>=0;i--)
    {
        mx[q[i]]=max(mx[q[i]],t-sz[q[i]]);
        if(mx[q[i]]*2<=t) return q[i];
        sz[f[q[i]]]+=sz[q[i]];
        mx[f[q[i]]]=max(mx[f[q[i]]],sz[q[i]]);
    }
    return 0;
}
void getdeep(int k,int fa,int f)
{
    father[k]=fa;
    dep[k]=dep[fa]+1;
    maxd[k]=dep[k];
    par[k]=f;
    L[k]=++t;
    p[t]=k;
    for(auto u:g[k])
    {
        if(u==fa||vis[u]) continue;
        getdeep(u,k,f);
        maxd[k]=max(maxd[k],maxd[u]);
    }
    R[k]=t;
}
void solve(int k)
{
    t=0;
    maxd[k]=dep[k]=0;
    L[k]=++t;
    p[1]=k;
    for(auto u:g[k])
    {
        if(vis[u]) continue;
        getdeep(u,k,u);
        maxd[k]=max(maxd[k],maxd[u]);
    }
    R[k]=t;

    for(int i=0;i<=maxd[k];++i) s[i]=0;
    for(int i=1;i<=t;++i)
    {
        int u=p[i];
        if(u>n) continue;
        ++s[dep[u]];
        if(dep[u]==D) res[k][par[u]]++;
    }
    ss[0]=s[0];
    for(int i=1;i<=maxd[k];++i) ss[i]=ss[i-1]+s[i];
    ans[k]+=ss[min(D-1,maxd[k])];
    for(int i=2;i<=t;++i)
    {
        int u=p[i];
        if(D-1-dep[u]>=0) ans[u]+=ss[min(D-1-dep[u],maxd[k])];
        if(D>=dep[u]&&D-dep[u]<=maxd[k])
        res[u][father[u]]+=s[D-dep[u]];
    }

    for(auto u:g[k])
    {
        if(vis[u]) continue;
        for(int i=0;i<=maxd[u];++i) s[i]=ss[i]=0;
        for(int i=L[u];i<=R[u];++i)
        {
            int v=p[i];
            if(v>n) continue;
            ++s[dep[v]];
        }
        ss[0]=s[0];
        for(int i=1;i<=maxd[u];++i) ss[i]=ss[i-1]+s[i];
        for(int i=L[u];i<=R[u];++i)
        {
            int v=p[i];
            if(D-1-dep[v]>=0) ans[v]-=ss[min(D-1-dep[v],maxd[u])];
            if(D>=dep[v]&&D-dep[v]<=maxd[u])
            res[v][father[v]]-=s[D-dep[v]];
        }
    }
    vis[k]=1;
    for(auto u:g[k])
    {
        if(vis[u]) continue;
        root=getroot(u);
        solve(root);
    }
}
```

### 点分树

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5;
vector<int> g[maxn+5];
int val[maxn+5];
int n,m,root;
//注意空间复杂度是O(nlog^2n)的
int sum[maxn*20*20+5],ch[maxn*20*20+5][2];
//u在点分树上的父亲是fa[u]，f[u]表示u控制的连通块到u的信息，ff[u]表示u控制的连通块到fa[u]的信息，ff是为了容斥的
int f[maxn+5],ff[maxn+5],fa[maxn+5];
bool vis[maxn+5];
namespace LCA
{
    int fa[maxn+5][17];
    int dep[maxn+5];
    void dfs(int k,int last)
    {
        fa[k][0]=last;
        dep[k]=dep[last]+1;
        for(auto u:g[k])
            if(u!=last) dfs(u,k);
    }
    void init()
    {
        dfs(1,0);
        for(int j=1;j<17;++j)
            for(int i=1;i<=n;++i)
                fa[i][j]=fa[fa[i][j-1]][j-1];
    }
    int lca(int u,int v)
    {
        if(dep[u]<dep[v]) swap(u,v);
        int d=dep[u]-dep[v];
        for(int i=0;i<17;++i) if(d&(1<<i)) u=fa[u][i];
        for(int i=16;i>=0;--i)
            if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
        if(u==v) return u;else return fa[u][0];
    }
    int dist(int u,int v)
    {
        return dep[u]+dep[v]-2*dep[lca(u,v)];
    }
}
int getroot(int u)
{
    static int q[maxn+5],f[maxn+5],mx[maxn+5],sz[maxn+5];
    int t=1;
    q[0]=u;
    f[u]=-1;
    for(int i=0;i<t;++i)
    {
        u=q[i];
        for(auto v:g[u])
            if (!vis[v]&&v!=f[u]) f[q[t++]=v]=u;
        mx[q[i]]=0;
        sz[q[i]]=1;
    }
    for (int i=t-1;i>=0;i--)
    {
        mx[q[i]]=max(mx[q[i]],t-sz[q[i]]);
        if(mx[q[i]]*2<=t) return q[i];
        sz[f[q[i]]]+=sz[q[i]];
        mx[f[q[i]]]=max(mx[f[q[i]]],sz[q[i]]);
    }
    return 0;
}
int tot=0;
void update(int k)
{
    sum[k]=sum[ch[k][0]]+sum[ch[k][1]];
}
void modify(int &k,int l,int r,int pos,int val)
{
    if(l>r) return;
    if(k==0) k=++tot;
    if(l==r)
    {
        sum[k]+=val;
        return;
    }
    int mid=(l+r)>>1;
    if(pos<=mid) modify(ch[k][0],l,mid,pos,val);
    else modify(ch[k][1],mid+1,r,pos,val);
    update(k);
}
int query(int k,int l,int r,int pos)
{
    if(!k||l>r) return 0;
    if(l==r) return sum[k];
    int mid=(l+r)>>1;
    if(pos<=mid) return query(ch[k][0],l,mid,pos);
    else return sum[ch[k][0]]+query(ch[k][1],mid+1,r,pos);
}
void dfs1(int k,int fa,int dis,int id)
{
    modify(f[id],0,n,dis,val[k]);
    for(auto u:g[k])
        if(u!=fa&&!vis[u]) dfs1(u,k,dis+1,id);
}
void dfs2(int k,int fa,int dis,int id)
{
    modify(ff[id],0,n,dis,val[k]);
    for(auto u:g[k])
        if(u!=fa&&!vis[u]) dfs2(u,k,dis+1,id);
}
void solve(int k)
{
    dfs1(k,0,0,k); //算f
    vis[k]=1;
    for(auto u:g[k])
    {
        if(vis[u]) continue;
        int root=getroot(u);
        assert(root!=0);
        fa[root]=k;
        dfs2(u,0,1,root); //算ff
        solve(root);
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) scanf("%d",&val[i]);
    for(int i=1;i<n;++i)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    LCA::init();
    root=getroot(1);
    solve(root);
    int ans=0;
    while(m--)
    {
        int op,x,y;
        scanf("%d%d%d",&op,&x,&y);
        x^=ans,y^=ans;
        if(op==0)
        {
            ans=query(f[x],0,n,y);
            int u=x;

            while(fa[u])
            {
                int d=LCA::dist(fa[u],x);
                if(y-d>=0)
                    ans+=query(f[fa[u]],0,n,y-d)-query(ff[u],0,n,y-d);
                u=fa[u];
            }
            printf("%d\n",ans);
        }
        else
        {
            modify(f[x],0,n,0,y-val[x]);
            int u=x;
            while(fa[u])
            {
                int d=LCA::dist(fa[u],x);
                modify(f[fa[u]],0,n,d,y-val[x]);
                modify(ff[u],0,n,d,y-val[x]);
                u=fa[u];
            }
            val[x]=y;
        }
    }
    return 0;
}
```



